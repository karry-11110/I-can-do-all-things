本markdown内容根据tonyBai老师的极客时间专栏<Go语言第一课>、书籍|<Go语言精进之路>整理而来。

# Go初闻

## Go的前世今生

### **编译和解释性语言**

**Golang兼具 Python等动态语言的开发速度和 C 语言以及 C++ 等静态语言的性能与安全性**，**go是一门动态特性的静态语言：**

- **编译单元import方式；**
- **接口特性**
- 支持**交叉编译**，也就是说 Go 语言可以在 Windows上开发，然后在 Linux 上运行

| 类型       | 原理                                                         | 优点                                                         | 缺点                                                         | 语言     |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | -------- |
| 编译型语言 | 通过专门的编译器，**将所有源代码一次性**转换成**特定平台**（Windows、Linux 等）执行的机器码（以可执行文件的形式存在）。一般需经过**编译、链接**这两个步骤。编译是把源代码编译成**机器码**，链接是把各个模块的机器码和依赖库串连起来生成**可执行文件** | 编译一次后，脱离了编译器也可以运行，并且运行效率高。         | 可移植性差，不够灵活。                                       | c,c++,go |
| 解释型语言 | 有专门的解释器，**根据需要将部分源代码临时转换**成**特定平台**的机器码。然后把各个模块的机器码和依赖库串连起来生成可执行文件 | 跨平台性好，通过不同的解释器，将相同的源代码解释成不同平台下的机器码。 | 一边执行一边转换，效率很低。                                 | python   |
| Java       | java针对不同的平台有不同的JVM，实现了跨平台。所以Java语言有一次编译到处运行 | 可以说它是编译型的：因为所有的Java代码都是要编译的，.java不经过编译就什么用都没有 | 可以说它是解释型的：因为java代码编译后不能直接运行，它是解释运行在JVM上的，所以它是解释运行的 |          |

| 静态语言 | 运行时结构不可变的语言就是静态语言       | java,c++,go |
| -------- | ---------------------------------------- | ----------- |
| 动态语言 | 在运行时代码可以根据某些条件改变自身结构 | python      |



### **Go 语言是怎样诞生的？**

**Go 语言的创始人**有三位，分别是图灵奖获得者、C 语法联合发明人、Unix 之父肯·汤普森（Ken Thompson），Plan 9 操作系统领导者、UTF-8 编码的最初设计者罗伯·派克（Rob Pike），以及 Java 的 HotSpot 虚拟机和 Chrome 浏览器的 JavaScript V8 引擎的设计者之一罗伯特·格瑞史莫（Robert Griesemer）

**之所以有这种想法，是因为**当时的谷歌内部主要使用 C++ 语言构建各种系统，但 C++ 的巨大复杂性、**编译构建速度慢**以及在编写服务端程序时**对并发支持的不足**

**主要思路是**，在 C 语言的基础上，修正一些明显的缺陷，删除一些被诟病较多的特性，增加一些缺失的功能，比如，使用 import 替代 include、去掉宏、增加垃圾回收、支持接口等

- 2008 年初，Unix 之父肯·汤普森实现了第一版 Go 编译器，用于验证之前的设计。这个编译器先将 Go 代码转换为 C 代码，再由 C 编译器编译成二进制文件。
- 同样在谷歌工作的伊恩·泰勒 （Ian Lance Taylor）为 Go 语言实现了一个 gcc 的前端，这也是 Go 语言的第二个编译器
- 罗斯·考克斯利用函数类型是“一等公民”，而且它也可以拥有自己的方法这个 特性巧妙设计出了 http 包的HandlerFunc类型。这样，我们通过显式转型就可以让一个 普通函数成为满足http.Handler接口的类型了
- 罗斯·考克斯还在当时设计的基础上提出了一些更泛化的想法，比如io.Reader 和io.Writer接口，这就奠定了 Go 语言的 I/O 结构模型

2009 年 11 月 10 日，谷歌官方宣布 Go 语言项目开源，之后这一天也被 Go 官方确 定为 **Go 语言的诞生日**

2012 年 3 月 28 日，Go 1.0 版本正式发布，同时 **Go 官方发布了“Go1 兼容性”承诺**： 只要符合 Go1 语言规范的源代码，Go 编译器将保证向后兼容（backwards compatible），也就是说我们使用新版编译器也可以正确编译用老版本语法编写的代码。



### Go**编译快的原因**

- **前沿知识：**Go的团队尝试设计实现一个Go语言的编译前端，由基于C的gcc编译器来编译成机器代码，这个面向gcc的前端编译器也就是目前的Go编译器之一的gccgo；C++也可以用gcc编译，编译速度的大部分差异很有可能来源于语言设计本身。

- **静态编译：**编译器在编译可执行文件时，要把使用到的链接库提取出来，链接打包进可执行文件中，编译结果只有一个可执行文件。
- **动态编译**：可执行文件需要附带独立的库文件，不打包库到可执行文件中，减少可执行文件体积，在执行的时候再调用库即可

- **c++编译慢的原因：**
  - 头文件的include方式 ：使用include方式引用头文件，会让需要编译的代码有乘数级的增加，例如当同一个头文件被同一个项目下的N个文件include时，编译器会将头文件引入到每一份代码中，所以同一个头文件会被编译N次
  - 模板的编译：使用的模板是为了支持泛型编程，在编写对不同类型的泛型函数时，可以提供很大的便利，但是这对于编译器来说，会增加非常多不必要的编译负担。
- **go编译快：**
  - 头文件的方式，**import解决了重复编译**的问题，当然Go也是使用的import方式；
  - 在模板的编译问题上，由于Go在设计理念上遵循从简入手，所以没有将泛函编程纳入到设计框架中，所以天生的**没有模版编译**带来的时间开销
  - 1.5版本后的**自举编译器**优化
  - **更少的关键字**



### **Go语言演化历史**

<img src="markdown%E5%9B%BE%E7%89%87/image-20221110101135271.png" alt="image-20221110101135271" style="zoom:150%;" />



## Go的设计哲学

> **简单**	

Go 语言的设计者们在语言设计之初，就拒绝了走语言特性融合的道路，选择了“**做减法**”并致力于打造一门简单的编程语言。

- 仅有 25 个关键字，主流编程语言最少；

- 内置垃圾收集，降低开发人员内存管理的心智负担；

- 首字母大小写决定可见性，无需通过额外关键字修饰；

- 变量初始为类型零值，避免以随机值作为初值的问题；

- 内置数组边界检查，极大减少越界访问带来的安全隐患；

- 内置并发支持，简化并发程序设计；

- 内置接口类型，为组合的设计哲学奠定基础；

- 原生提供完善的工具链，开箱即用；

- … …



> **显示**

- 在 Go 语言中，不同类型变量是不能在一起进行混合计算的，这是**因为 Go 希望开发人员明确知道自己在做什么**，这与 C 语言的“信任程序员”原则完全不同，因此你需要以显式的方式通过转型统一参与计算各个变量的类型。

- 除此之外，Go 设计者所崇尚的**显式哲学**还直接决定了 **Go 语言错误处理的形态**：Go 语言采用了显式的基于值比较的错误处理方案，函数 / 方法中的错误都会通过 return 语句显式地返回，并且通常调用者不能忽略对返回的错误的处理

 

> **组合**

 这个设计哲学和我们各个程序之间的耦合有关，Go 语言不像 C++、Java 等主流面向对象语言，我们在 Go 中是找不到经典的面向对象语法元素、类型体系和继承机制的，**Go 推崇的是组合的设计哲学**。

在诠释组合之前，我们需要先来了解一下 Go 在语法元素设计时，是如何为“组合”哲学的应用奠定基础的。在 Go 语言设计层面，Go 设计者为开发者们提供了**正交的语法元素**，以供后续组合使用，包括：

- Go 语言无类型层次体系，各类型之间是相互独立的，没有子类型的概念；

- 每个类型都可以有自己的方法集合，类型定义与方法实现是正交独立的；

- 实现某个接口时，无需像 Java 那样采用特定关键字修饰；

- 包之间是相对独立的，没有子包的概念。

我们可以看到，无论是包、接口还是一个个具体的类型定义，Go 语言其实是为我们呈现了这样的一幅图景：一座座没有关联的“孤岛”，但每个岛内又都很精彩。那么现在摆在面前的工作，就是在这些孤岛之间以最适当的方式建立关联，并形成一个整体。**而 Go 选择采用的组合方式，也是最主要的方式。**

- Go 语言为支撑组合的设计提供了**类型嵌入**（Type Embedding）。通过类型嵌入，我们可以将已经实现的功能嵌入到新类型中，以快速满足新类型的功能需求，这种方式有些类似经典面向对象语言中的“继承”机制，但在原理上却与面向对象中的继承完全不同，这是一种 Go 设计者们精心设计的“语法糖”。

  被嵌入的类型和新类型两者之间没有任何关系，甚至相互完全不知道对方的存在，更没有经典面向对象语言中的那种父类、子类的关系，以及向上、向下转型（Type Casting）。通过新类型实例调用方法时，方法的匹配主要取决于方法名字，而不是类型。这种组合方式，我称之为**垂直组合**，即**通过类型嵌入，快速让一个新类型“复用”其他类型已经实现的能力，实现功能的垂直扩展**。

- **水平组合**是一种能力委托（Delegate），我们通常使用接口类型来实现水平组合。Go 语言中的接口是一个创新设计，它只是方法集合，并且它与实现者之间的关系无需通过显式关键字修饰，它让程序内部各部分之间的耦合降至最低，同时它也是连接程序各个部分之间“纽带”



> **并发**

“并发”这个设计哲学的出现有它的背景，你也知道 CPU 都是靠提高主频（即时钟频率）来改进性能的，但是现在这个做法已经遇到了瓶颈。主频提高导致 CPU 的功耗和发热量剧增，反过来制约了 CPU 性能的进一步提高。2007 年开始，处理器厂商的竞争焦点从主频转向了多核。

Rob Pike：“并行关乎执行，并发关乎结构。”

- 在这种大背景下，Go 的设计者在决定去创建一门新语言的时候，果断将面向多核、原生支持并发作为了新语言的设计原则之一。并且，Go 放弃了传统的基于操作系统线程的并发模型，而采用了**用户层轻量级线程**，Go 将之称为 **goroutine。**

  goroutine 占用的资源非常小，Go 运行时默认为每个 goroutine 分配的栈空间仅 2KB。goroutine 调度的切换也不用陷入（trap）操作系统内核层完成，代价很低。因此，一个 Go 程序中可以创建成千上万个并发的 goroutine。而且，所有的 Go 代码都在 goroutine 中执行，哪怕是 go 运行时的代码也不例外。

- 在提供了开销较低的 goroutine 的同时，Go 还在语言层面内置了**辅助并发设计的原语： channel 和 select**。开发者可以通过语言内置的 channel 传递消息或实现同步，并通过 select 实现多路 channel 的并发控制。相较于传统复杂的线程并发模型，Go 对并发的原 生支持将大大降低开发人员在开发并发程序时的心智负担。



> **面向工程**

Go 语言设计的初衷，就是面向解决真实世界中 Google 内部大规模软件开发存在的各种问题，为这些问题提供答案，这些问题包括：程序构建慢、依赖管理失控、代码难于理解、跨语言构建难等。

Go 在语法设计细节上做了精心的打磨。比如：

- 重新设计编译单元和目标文件格式，实现 Go 源码快速构建，让大工程的构建时间缩短到类似动态语言的交互式解释（import方式）的编译速度；

- 如果源文件导入它不使用的包，则程序将无法编译。这可以充分保证任何 Go 程序的依赖树是精确的。这也可以保证在构建程序时不会编译额外的代码，从而最大限度地缩短编译时间；

- 去除包的循环依赖，循环依赖会在大规模的代码中引发问题，因为它们要求编译器同时处理更大的源文件集，这会减慢增量构建；

- 包路径是唯一的，而包名不必唯一的。导入路径必须唯一标识要导入的包，而名称只是包的使用者如何引用其内容的约定。“包名称不必是唯一的”这个约定，大大降低了开发人员给包起唯一名字的心智负担；

- 故意不支持默认函数参数。因为在规模工程中，很多开发者利用默认函数参数机制，向函数添加过多的参数以弥补函数 API 的设计缺陷，这会导致函数拥有太多的参数，降低清晰度和可读性；

- 增加类型别名（type alias），支持大规模代码库的重构。

- 在标准库方面，Go 被称为“自带电池”的编程语言。如果说一门编程语言是“自带电池”，则说明这门语言标准库功能丰富，多数功能不需要依赖外部的第三方包或库，Go 语言恰恰就是这类编程语言。



## Go程序结构

### **第一个Go程序**

```go
package main
import "fmt"
func main() {
	fmt.Println("hello, world")
}

```

包是 Go 语言的基本组成单元，通常使用单 个的小写单词命名，一个 Go 程序本质上就是一组包的集合。所有 Go 代码都有自己隶属 的包，在这里我们的“hello，world”示例的所有代码都在一个名为 main 的包中。main 包在 Go 中是一个特殊的包，**整个 Go 程序中仅允许存在一个名为 main 的包**

这里的 **main 函数会比较特殊**：当你运行一个可执行的 Go 程序的时候，所有的代码都会 从这个入口函数开始运行。

**注意点**：

- 标准 **Go 代码风格使用 Tab** 而不是空格来实现缩进的
- 我们**调用了一个名为 Println 的函数**，这个函数位于 Go 标准库的 fmt 包中。 为了在我们的示例程序中使用 fmt 包定义的 Println 函数，我们其实做了两步操作
  - 第一步是在源文件的开始处通过 import 声明导入 fmt 包的包路径。（import “fmt” 一行中“fmt”代表的是包的导入路径（Import），它表示的是标准库 下的 fmt 目录，整个 import 声明语句的含义是导入标准库 fmt 目录下的包；）
  - 第二步则是在 main 函数体中，通过 fmt 这个限定标识符（Qualified Identifier）调用 Println 函数（fmt.Println 函数调用一行中的“fmt”代表的则是包名，**通常导入路径的最后一个分段名与包名是相同的，这也很容易让人误解 import 声明语句中 的“fmt”指的是包名，其实并不是这样的**。）main 函数体中之所以可以调用 fmt 包的 Println 函数，还有最后一个原因，那就是 Println 函数名的首字母是大写的。在 Go 语言中，只有首字母为大写的标识符才是导出的 （Exported），才能对包外的代码可见；如果首字母是小写的，那么就说明这个标识符仅 限于在声明它的包内可见
- 我们传入的字符串也就是我们执行程序后在终端的标 准输出上看到的字符串。 这种“所见即所得”得益于 **Go 源码文件本身采用的是 Unicode 字符集，而且用的是 UTF-8 标准的字符编码方式**，这与编译后的程序所运行的环境所使用的字符集和字符编码 方式是一致的。



### **Go语言程序是怎么编译的？**

Go 是一种编译型语言，这意味着只有你编译完Go 程序之后，才可以将生成的可执行文件交付于其他人，并运行在没有安装 Go 的环境 中。比如以上一个简单的程序只需要`go build main.go`就可以完成编译成可运行文件。

**但是在我们的生产环境里**，Go 程序的编译往往不会像我们前面，基于单个 Go 源文件构建 类似“hello，world”这样的示例程序那么简单。越贴近真实的生产环境，也就意味着项 目规模越大、协同人员越多，**项目的依赖和依赖的版本都会变得复杂**。



### **复杂项目下Go程序的编译**

**Go module 构建模式**是在 Go 1.11 版本正式引入的，为的是彻底解决 Go 项目复杂版本 依赖的问题，在 Go 1.16 版本中，**Go module 已经成为了 Go 默认的包依赖管理机制和 Go 源码构建机制。**

Go Module 的核心是一个名为 go.mod 的文件，在这个文件中存储了这个 module 对第 三方依赖的全部信息。`go mod init` 命令的执行结果是在当前目录下生成了一个 go.mod 文件。其实，**一个 module 就是一个包的集合**，这些包和 module 一起打版本、发布和分发。 go.mod 所在的目录被我们称为它声明的 module 的根目录。

- 第一行内容是用于**声明 module 路径** （module path）的。而且，module **隐含了一个命名空间**的概念，module 下每个包的 导入路径都是由 module path 和包所在子目录的名字结合在一起构成。

```go
module github.com/bigwhite/hellomodule
go 1.16
require (
	github.com/valyala/fasthttp v1.28.0
	go.uber.org/zap v1.18.1
)

```

这个时候，go.mod 已经记录了 hellomodule 直接依赖的包的信息。不仅如此， hellomodule 目录下还多了一个名为 go.sum 的文件，这个文件记录了 hellomodule 的 直接依赖和间接依赖包的相关版本的 hash 值，用来校验本地包的真实性。在构建的时 候，如果本地依赖包的 hash 值与 go.sum 文件中记录的不一致，就会被拒绝构建。



## Go项目标准布局

一个 Go 项目通常分为**可执行程序项目和库项目。**

### Go**可执行程序项目典型结构布局**

![image-20221110165836236](markdown%E5%9B%BE%E7%89%87/image-20221110165836236.png)

- **cmd目录**：cmd 目录就是存放项目要编译构建的可执行 文件对应的 main 包的源文件。如果你的项目中有多个可执行文件需要构建，每个可执行 文件的 main 包单独放在一个子目录中，比如图中的 app1、app2，cmd 目录下的各 app 的 main 包将整个项目的依赖连接在一起。main 包应该很简洁。我们在 main 包中会做一些命令行参数解析、资源初 始化、日志设施初始化、数据库连接初始化等工作，之后就会将程序的执行权限交给更高 级的执行控制对象。另外，也有一些 Go 项目将 cmd 这个名字改为 app 或其他名字，但 它的功能其实并没有变。
-  **pkgN 目录**：这是一个存放项目自身要使用、同样也是可执行文件对应 main 包所要依赖的库文件，同时这些目录下的包还可以被外部项目引用
- **go.mod 和 go.sum**：它们是 Go 语言包依赖管理使用的配置文件
- **vendor 目录**：vendor 是 Go 1.5 版本引入的用于在项目本地缓存特定 版本依赖包的机制，在 Go Modules 机制引入前，基于 vendor 可以实现可重现构建，保证基于同一源码构建出的可执行程序是等价的
  - 这里将 vendor 目录视为一个可选目录。原因在于，Go Module 本身就支持 可再现构建，而无需使用 vendor。 当然 Go Module 机制也保留了 vendor 目录（通过 go mod vendor 可以生成 vendor 下的依赖包，通过 go build -mod=vendor 可以实现 基于 vendor 的构建）。一般我们仅保留项目根目录下的 vendor 目录，否则会造成不必 要的依赖选择的复杂性。
- **internal 目录**：存放仅项目内部引用的 Go 包，这些包无法被项目之外引用；



### Go**库项目标准布局**

Go 库项目**仅对外暴露 Go 包**

![image-20221110170521320](markdown%E5%9B%BE%E7%89%87/image-20221110170521320.png)



## Go构建模式

### **Go构建模式是怎么演化的？**

Go 程序由 Go 包组合而成的，**Go 程序的构建过程就是确定包版本、编译包以及将编译后 得到的目标文件链接在一起的过程**。 

Go 语言的构建模式历经了三个迭代和演化过程，分别是最初期的 GOPATH、1.5 版本的 Vendor 机制，以及现在的 Go Module。



### **GOPATH**

在这种构建模式下， Go 编译器可以在本地 GOPATH 环境变量配置的路径下，搜寻 Go 程序依赖的第三方包。 如果存在，就使用这个本地包进行编译；如果不存在，就会报编译错误。

为了给你说清楚搜寻规则，我们先假定 Go 程序导入了 github.com/user/repo 这个包， 我们也同时假定当前 GOPATH 环境变量配置的值为：`export GOPATH=/usr/local/goprojects:/home/tonybai/go`

那么在 GOPATH 构建模式下，Go 编译器在编译 Go 程序时，就会在下面两个路径下搜索 第三方依赖包是否存在：

```go
/usr/local/goprojects/src/github.com/user/repo
/home/tonybai/go/src/github.com/user/repo
```

**这里注意一下**，如果你没有显式设置 GOPATH 环境变量，Go 会将 GOPATH 设置为默认 值，不同操作系统下默认值的路径不同，在 macOS 或 Linux 上，它的默认值是 $HOME/go。

如果在GOPATH中找不到包怎么办，让**go get登场**。

通过 go get 命令将本地缺失的第三方依赖包下载到本地`go get github.com/sirupsen/logrus`。这里的 go get 命令，不仅能将 logrus 包下载到 GOPATH 环境变量配置的目录下，它还 会检查 logrus 的依赖包在本地是否存在，如果不存在，go get 也会一并将它们下载到本 地。

但**缺点是**：

- go get 下载的包只是那个时刻各个依赖包的最新主线版本，这样会给后续 Go 程序 的构建带来一些问题。比如，依赖包持续演进，可能会导致不同开发者在不同时间获取和 编译同一个 Go 包时，得到不同的结果，也就是不能保证可重现的构建
- 如果依赖包引入了不兼容代码，程序将无法通过编译
- 如果依赖包因引入新代码而无法正常通过编译，并且该依赖包的作者又没 用及时修复这个问题，这种错误也会传导到你的程序，导致你的程序无法通过编译

**也就是说，在 GOPATH 构建模式下，Go 编译器实质上并没有关注 Go 项目所依赖的第三 方包的版本**。



### **Vendor机制**

**vendor 机制本质上就是在 Go 项目的某个特定目录 下，将项目的所有依赖包缓存起来，这个特定目录名就是 vendor**

Go 编译器会优先感知和使用 vendor 目录下缓存的第三方包版本，而不是 GOPATH 环境 变量所配置的路径下的第三方包版本。这样，无论第三方依赖包如何变化，无论 GOPATH 环境变量所配置的路径下的第三方包是否存在、版本是啥，都不会影响到 Go 程序的构建。

如果你将 vendor 目录和项目源码一样提交到代码仓库，那么其他开发者下载你的项目 后，就可以实现可重现的构建。因此，如果使用 vendor 机制管理第三方依赖包，最佳实 践就是将 vendor 一并提交到代码仓库中。

**要注意一点**，要想开启 vendor 机制，你的 Go 项目必须位于 GOPATH 环境变量 配置的某个路径的 src 目录下面。如果不满足这一路径要求，那么 Go 编译器是不会理会 Go 项目目录下的 vendor 目录的

**但缺点是**：

- Go 项目必须放在 GOPATH 环境变量配置的路径下
- 庞大的 vendor 目录需要提交到代码仓库，不仅占用代码仓库空间，减慢仓库下载和更新的速度， 而且还会干扰代码评审，对实施代码统计等开发者效能工具也有比较大影响。



### **Go Module构建机制**

基于当前项目创建一个 Go Module，通常有如下几个步骤： 

- 第一步，通过 go mod init 创建 go.mod 文件，将当前项目变为一个 Go Module；
-  第二步，通过 go mod tidy 命令自动更新当前 module 的依赖信息； 
  - Go Module 还支持通过 Go Module 代理服务加速第三方依赖的下载。 GOPROXY 环境变量，这个环境变量的默认值为“https: // proxy.golang.org,direct”
  - 由 go mod tidy 下载的依赖 module 会被放置在本地的 module 缓存路径下，默认值为 $GOPATH[0]/pkg/mod，Go 1.15 及以后版本可以通过 GOMODCACHE 环境变量，自 定义本地 module 的缓存路径。
  - go.sum这同样是由 go mod 相关命令维护的一个文件，它存放了特定版本 module 内容的哈希 值。 这是 Go Module 的一个安全措施。当将来这里的某个 module 的特定版本被再次下载的 时候，go 命令会使用 go.sum 文件中对应的哈希值，和新下载的内容的哈希值进行比对， 只有哈希值比对一致才是合法的，这样可以确保你的项目所依赖的 module 内容，不会被 恶意或意外篡改
- 第三步，执行 go build，执行新 module 的构建
  - go build 命令会读取 go.mod 中的依赖及版本信息，并在本地 module 缓存路径下找到 对应版本的依赖 module，执行编译和链接



### **深入Go Module构建模式**

> **Go Module的语义导入版本机制**

 go.mod 的 require 段中依赖的版本号，都符合 vX.Y.Z 的格 式。在 Go Module 构建模式下，一个符合 Go Module 要求的版本号，由前缀 v 和一个 满足语义版本规范的版本号组成。语义版本号分成 3 部分：主版本号 (major)、次版本号 (minor) 和补丁版本号 (patch)。

- 按照语义版本规范，主版本号不同的两个版本是相互不兼容的。
- 在主版本号相同的 情况下，次版本号大都是向后兼容次版本号小的版本。
- 补丁版本号也不影响兼容性
- **Go Module 规定：如果同一个包的新旧版本是兼容的，那么它们的包导入路径应该 是相同的**
  - 以 logrus 为例，它有很多发布版 本，我们从中选出两个版本 v1.7.0 和 v1.8.1.。按照上面的语义版本规则，这两个版本的主 版本号相同，新版本 v1.8.1 是兼容老版本 v1.7.0 的。那么，我们就可以知道，如果一个项 目依赖 logrus，无论它使用的是 v1.7.0 版本还是 v1.8.1 版本，它都可以使用下面的包导 入语句导入 logrus 包：`import "github.com/sirupsen/logrus"`
  - 假如在未来的某一天，logrus 的作者发布了 logrus v2.0.0 版本。那么 根据语义版本规则，该版本的主版本号为 2，已经与 v1.7.0、v1.8.1 的主版本号不同了， 那么 v2.0.0 与 v1.7.0、v1.8.1 就是不兼容的包版本。如果一个项目依赖 logrus v2.0.0 版本，那么它的包导入路径就不能再与上面的导入方 式相同了。Go Module 创新性地给出了一个方法：将包主版本号引入到包导入路径中，我们可以像下 面这样导入 logrus v2.0.0 版本依赖包：` import "github.com/sirupsen/logrus/v2"`



> **Go Module的最小版本选择机制**

![image-20221110182355428](markdown%E5%9B%BE%E7%89%87/image-20221110182355428.png)

在这张图中，myproject 有两个直接依赖 A 和 B，A 和 B 有一个共同的依赖包 C，但 A 依 赖 C 的 v1.1.0 版本，而 B 依赖的是 C 的 v1.3.0 版本，并且此时 C 包的最新发布版为 C v1.7.0。这个时候，Go 命令是如何为 myproject 选出间接依赖包 C 的版本呢？选出的究 竟是 v1.7.0、v1.1.0 还是 v1.3.0 呢？

**Go 会在该项目依赖项的所有版本中，选出符合项 目整体要求的“最小版本”。**这个例子中，C v1.3.0 是符合项目整体要求的版本集合中的版本最小的那个，于是 Go 命 令选择了 C v1.3.0，而不是最新最大的 C v1.7.0



> **Go Module模式下的几种常规操作**

**go get** : go get 命令将我们新增的依赖包下载到了本地 module 缓存里，并在 go.mod 文件的 require 段中新增了一行内容

**go mod tidy** : 在执行构建前自动分析源码中的依赖变化，识别新增依赖项并下载它们



## Go程序的执行次序

### **main.main函数**

main 包中的 main 函数，也就是 main.main，它是所有 Go 可执行程序的用户层执行逻辑的入口函数。Go 程序在用户层面的执行逻辑，会在这个 函数内按照它的调用顺序展开。

Go 语言要 求：**可执行程序的 main 包必须定义 main 函数，否则 Go 编译器会报错**。在启动了多个 Goroutine（Go 语言的轻量级用户线程，后面我们会详细讲解）的 Go 应用中， main.main 函数将在 Go 应用的主 Goroutine 中执行。

还**值得我们注意的是**，除了 main 包外，其他包也可以拥有自己的名为 main 的函数 或方法。但按照 Go 的可见性规则（小写字母卡头的标识符为非导出标识符），非 main 包中自定义的 main 函数仅限于包内使用



### **init函数：Go包的初始化函数**

Go 语言还有一个特殊函数，它就是用于**进行包初 始化的 init 函数了**

“**main 函数不一定是用户层第一个被执行的函数”的问题**“，其实 就是因为，如果 main 包依赖的包中定义了 init 函数，或者是 main 包自身定义了 init 函 数，那么 Go 程序在这个包初始化的时候，就会自动调用它的 init 函数，因此这些 init 函 数的执行就都会发生在 main 函数之前。

 不过对于 init 函数来说，我们还需要注意一点，就是在 Go 程序中我们不能手工显式地调 用 init，否则就会收到编译错误。

实际上，Go 包可以拥有不止一个 init 函数，每个组成 Go 包的 Go 源文件中，也可以定义 多个 init 函数。 所以说，在初始化 Go 包时，Go 会按照一定的次序，逐一、顺序地调用这个包的 init 函 数。一般来说，先传递给 Go 编译器的源文件中的 init 函数，会先被执行；而同一个源文 件中的多个 init 函数，会按声明顺序依次执行。

**init函数的三个常用用途**：

- 重置包级变量值
- 实现对包级变量的复杂初始化
- 在 init 函数中实现“注册模式”。



### **Go包初始化次序**

Go 包是程序逻辑封装的基本单元，每个包都可以理解为是 一个“自治”的、封装良好的、对外部暴露有限接口的基本单元。

一个 Go 程序就是由一 组包组成的，程序的初始化就是这些包的初始化。

每个 Go 包还会有自己的依赖包、常 量、变量、init 函数（其中 main 包有 main 函数）等。

![image-20221110192439030](markdown%E5%9B%BE%E7%89%87/image-20221110192439030.png)



## Go语言原生编程思维

面对同一个问题，不同编程语言的程序员给出了不同思维方式的解决办法：C的命令式思维、Go的并发思维。

因此，**编程语言影响编程思维。**



## Go进阶路线图

借用“T 字形”发展模式，按语言深度与工程宽度两个方向，在一幅图中列出 Go 进阶需要了解的知识与技能点：

![image-20221117112928725](markdown%E5%9B%BE%E7%89%87/image-20221117112928725.png)



## Go学习资源

> **Go技术书籍**

1. Go程序设计语言-人手一本的Go语言“圣经”

   [前言 · Go语言圣经 (studygolang.com)](https://books.studygolang.com/gopl-zh/)

2. Go语言实战-实战系列经典之作，紧扣 Go 语言的精华

   `E:\学习书籍\Go技术`

3. Go语言学习笔记\- Go 源码剖析与实现原理探索

4. 《Go 101》- Go 语言参考手册

5. **Concurrency in Go**

   

> **blog**

1. TonyBai--Go语言第一课，Go技术杂文分享

   [文章列表 | Tony Bai](https://tonybai.com/articles/)

2. 刘丹冰--Go修养之路、Go设计模式

   [刘丹冰Aceld · 语雀 (yuque.com)](https://www.yuque.com/aceld)

3. mohuishou--极客时间Go训练营、设计模式笔记记录

   [Mohuishou (lailin.xyz)](http://lailin.xyz/)



> **网站**

1. Go语言中文网

   [首页 - Go语言中文网 - Golang中文社区 (studygolang.com)](https://studygolang.com/)

2. 地鼠文档-Go资料大全

   [地鼠文档 (topgoer.cn)](https://www.topgoer.cn/)



## 学习路径

**Go语言基础**

- 极客时间《GO语言第一课》专栏--白明  √
- 书籍《GO语言精进之路》--白明 
- 书籍《GO语言实战》-- 直击要点，也就是挑出 Go 语言和其他语言相比与众不同的特 点进行着重讲解 --`E:\学习书籍\Go技术`
- 书籍《GO语言学习笔记》-- 雨痕 --Go 源码剖析与实现原理探索
- 书籍《The Go programming》--Go语言圣经 --[介绍-地鼠文档 (topgoer.cn)](https://www.topgoer.cn/docs/gopl-zh/gopl-zh-1d29qo5qbk3js)

**Go语言并发编程**

- 极客时间《GO语言第一课》专栏--白明   √
- 极客时间《Go并发编程实战课》--鸟窝
- 书籍《Go并发编程实战》--郝林

**Go Web**

- 书籍《Go Web编程》--谢孟军

**Go设计模式**

- Go修养之路、Go设计模式--刘丹冰--[刘丹冰Aceld · 语雀 (yuque.com)](https://www.yuque.com/aceld)
- 设计模式笔记记录---mohuishou---[Mohuishou (lailin.xyz)](http://lailin.xyz/)

**Go微服务**

**Go项目**

- 极客时间《Go语言第一课》demo级项目
- 极客时间《手把手带你写一个Web框架》-- 叶剑峰 
- 极客时间《Go 语言项目开发实战》-- 孔令飞
- 极客时间Go训练营-- mohuishou---[Mohuishou (lailin.xyz)](http://lailin.xyz/)
- 微服务商城



# 变量

## **变量声明：静态语言有别于动态语言的重要特征**

> **变量概念**

在编程语言中，为了方便操作内存特定位置的数据，我们用一个特定的名字与位于特定位 置的内存块绑定在一起，这个名字被称为**变量**。

但这并不代表我们可以通过变量随意引用或修改内存，**变量所绑定的内存区域是要有一个 明确的边界的**。也就是说，通过这样一个变量，我们究竟可以操作 4 个字节内存还是 8 个 字节内存，又或是 256 个字节内存，编程语言的编译器或解释器需要明确地知道。

**动态语言和静态语言有不同的处理方式**。

动态语言（比如 Python、Ruby 等）的解 释器可以在运行时通过对变量赋值的分析，自动确定变量的边界。并且在动态语言中，一 个变量可以在运行时被赋予大小不同的边界。 而静态编程语言在这方面的“体验略差”。

静态类型语言编译器必须明确知道一个变量的 边界才允许使用这个变量，但静态语言编译器又没能力自动提供这个信息，这个边界信息 必须由这门语言的使用者提供，于是就有了“**变量声明**”。通过变量声明，语言使用者可 以显式告知编译器一个变量的边界信息。在具体实现层面呢，这个边界信息由变量的类型 属性赋予。 作为身处静态编程语言阵营的 Go 语言，它沿袭了静态语言的这一要求：使用变量之前需 要先进行变量声明。 首先，让我们先来看看 Go 语言的变量



## **Go语言变量声明方法**

> **通用声明方法**

```go
var a int = 10
var a int   // a的初值为int类型的零值：0
```

如果你没有显式为变量赋予初值，Go 编译器会为变量赋予这个类型的零值, 什么是类型的零值呢？Go 语言的每种原生类型都有它的默认值（这些原生类型我们后面再 讲），这个默认值就是这个类型的零值。

**注意点**：将**变量名放在了类型的前面**，这样做的好处也是在C语言基础上增加了可读性，比如有指针类型参数的时候。

除了单独声明每个变量外，Go 语言还提供了变量声明块（block）的语法形式，可以用一 个 var 关键字将多个变量声明放在一起:

```go
var (
	a int = 128
	b int8 = 6
	s string = "hello"
	c rune = 'A'
	t bool = true
)
```

Go 语言还支持在一行变量声明中同时声明多个变量：

```go
var a, b, c int = 5, 6, 7

var (
	a, b, c int = 5, 6, 7
	c, d, e rune = 'C', 'D', 'E'
)
```

**注意点**：变量必须声明且使用，全局变量可以只声明。



> **两种”语法糖式“声明**

1. 在通用的变量声明的基础上，Go 编译器允许我们省略变量声明中的类型信息，它的标准范 式是“**var varName = initExpression**”。道理其实很简单，Go 编译器会根据右侧变量初值自动推导出变量的类型，并给这个变量赋予初 值所对应的默认类型。

   如果我们不接受默认类型，而是要显式地为变量指定类型，除了通用的声明形式，我们还 可以通过显式类型转型达到我们的目的：` var b = int32(13)`

2. **短变量声明**：它的标准范式是“varName := initExpression”，短变量声明中的变量类型也是由 Go 编译器自动推导出来的，而且，短变量声明也支持一次声明多个变量，而且形式更为简洁，是这个样子的：` a, b, c := 12, 'A', "hello"`。**不过并不是所有变量都能用短变量来声明！**

   **注意点**：**短变量**的**本质**是先声明后赋值

   - 不能是包级变量，只能在函数内部使用
   - 不能重复声明，除非：=左边有新的变量名称

   - 不能用这种方式设置字段值

   - **注意短变量的词法域，别造成幽灵变量现象**



## **Go语言的俩类变量**

**注意点**：_表示匿名变量，不占用内存空间，也不存在重复声明。这也是**Go变量命名不要使用 _ 的原因**。

> **包级变量**

在包级别可见的变量。如果是导出变量（大写字母开头），那么这个包级变量也可以被视 为全局变量。**包级变量只能使用带有 var 关键字的变量声明形式，不能使用短变 量声明形式，但在形式细节上可以有一定灵活度**，灵活度的话我们可 以从“**变量声明时是否延迟初始化**”这个角度，对包级变量的声明形式进行一次分类。

- **第一类：声明同时显示初始化**

```go
// $GOROOT/src/io/io.go
var ErrShortWrite = errors.New("short write")
var ErrShortBuffer = errors.New("short buffer")
```

在 Go 标准库中，对于变 量声明的同时进行显式初始化的这类包级变量，实践中多使用这种省略类型信息的“语法 糖”格式

```go
//第一种：
var a = 13 // 使用默认类型
var b int32 = 17 // 显式指定类型
var f float32 = 3.14 // 显式指定类型
//第二种：
var a = 13 // 使用默认类型
var b = int32(17) // 显式指定类型
var f = float32(3.14) // 显式指定类型
```

虽然这两种方式都是可以使用的，但从声明一致性的角度出发，Go 更推荐我们使用后者， 这样能统一接受默认类型和显式指定类型这两种声明形式，尤其是在将这些变量放在一个 var 块中声明时，你会更明显地看到这一点。



- **第二类：声明但延迟初始化**

对于声明时并不立即显式初始化的包级变量，我们可以使用下面这种通用变量声明形式：

```go
var a int32
var f float64
```

虽然没有显式初始化，Go 语言也会让这些变量拥有初始的“零值”。如果是自 定义的类型，我也建议你尽量保证它的零值是可用的。

这里还有一个注意事项：**声明聚类与就近原则**

```go
// $GOROOT/src/net/net.go
var (
	netGo bool
	netCgo bool
)
var (
	aLongTimeAgo = time.Unix(1, 0)
	noDeadline = time.Time{}
	noCancel = (chan struct{})(nil)
)
```

通常，我们会将同一类的变量声明放在一个 var 变量声明块中，不同类的声明放在不同的 var 声明块中，我们可以将延迟初始化的变量声明放在一个 var 声明块 (比如上面的第一个 var 声明 块)，然后将声明且显式初始化的变量放在另一个 var 块中（比如上面的第二个 var 声明 块），这里我称这种方式为“**声明聚类**”

我们是否应该将包级变量的声明全部集中放在源文件头 部呢？答案不能一概而论。 使用静态编程语言的开发人员都知道，变量声明最佳实践中还有一条：**就近原则**。也就是 说我们尽可能在靠近第一次使用变量的位置声明这个变量。就近原则实际上也是对变量的 作用域最小化的一种实现手段



> **局部变量**

 Go 函数或方法体内声明的变 量，仅在函数或方法体内可见。和包级变量相比，**局部变量 又多了一种短变量声明形式**，这是局部变量特有的一种变量声明形式，也是局部变量采用 最多的一种声明形式。也从“变量声明的时候是否延迟初始化”这个角度，对本地变量的声明形式进行 分类说明。

- **第一类：对于延迟初始化的局部变量声明，我们采用通用的变量声明形式**

- **第二类：对于声明且显式初始化的局部变量，建议使用短变量声明形式**。这里我们还要注意：**尽量在分支控制时使用短变量声明形式。**在编写 Go 代码时，我们 很少单独声明用于分支控制语句中的变量，而是将它与 if、for 等控制语句通过短变量声明形式融合在一起，即在控制语句中直接声明用于控制语句代码块中的变量。

  ```go
  if len(s) > 8 {
  // 作者注：在if条件控制语句中使用短变量声明形式声明了if代码块中要使用的变量as和isA
      if as, isASCII := makeASCIISet(chars); isASCII {
          for i := len(s) - 1; i >= 0; i-- {
              if as.contains(s[i]) {
              return i
              }
              }
              return -1
              }
          }
          for i := len(s); i > 0; {
                  // 作者注：在for循环控制语句中使用短变量声明形式声明了for代码块中要使用的变量c
                  r, size := utf8.DecodeLastRuneInString(s[:i])
                  i -= size
                  for _, c := range chars {
                  if r == c {
                  return i
              }
       }
  }
  ```

  

# 代码块和作用域

## **Go变量遮蔽问题**

```go
var a = 11
func foo(n int) {
	a := 1
	a += n
}
func main() {
    fmt.Println("a =", a) // 11
    foo(5)
    fmt.Println("after calling foo, a =", a) // 11
}
```

变量遮蔽只是个引子，真正关键的是**代码块**（Block）和**作用域** （Scope）这两个概念，因为要想彻底保证不出现变量遮蔽问题，我们需要深入了解这两 个概念以及其背后的规则。



## **代码块与作用域**

> **代码块**

Go 语言中的代码块是包裹在一对大括号内部的声明和语句序列，如果一对大括号内部没有 任何声明或其他语句，我们就把它叫做空代码块。Go 代码块支持嵌套，我们可以在一个代 码块中嵌入多个层次的代码块。

**显示代码块**：由两个肉眼可见的且配对的大括号包裹起 来的。

**隐式代码块**：隐式代码块没有显式代码块那样的肉眼可见的配对大括号包裹，我们无法通过大括号 来识别隐式代码块，Go 语言规范对 现存的几类隐式代码块做了明确的定义

- 首当其冲的就是位于最外层的**宇宙代码块**（Universe Block），它囊括的范围最大，所有 Go 源码都在这个隐式代码块中，你也可以将该隐式代码块想象为在所有 Go 代码的最外层 加一对大括号
- 在宇宙代码块内部嵌套了**包代码块**（Package Block），每个 Go 包都对应一个隐式包代 码块，每个包代码块包含了该包中的所有 Go 源码，不管这些代码分布在这个包里的多少 个的源文件中。
- 在包代码块的内部嵌套着若干**文件代码块**（File Block），每个 Go 源文 件都对应着一个文件代码块，也就是说一个 Go 包如果有多个源文件，那么就会有多个对 应的文件代码块。
- 再下一个级别的隐式代码块就在控制语句层面了，包括 if、for 与 switch。我们可以把每 个控制语句都视为在它自己的隐式代码块里

如下图：

![image-20221111105328412](markdown%E5%9B%BE%E7%89%87/image-20221111105328412.png)



> **作用域**

作用域的概念是针对标识符 的，不局限于变量。每个标识符都有自己的作用域，而**一个标识符的作用域就是指这个标 识符在被声明后可以被有效使用的源码区域**。 显然，作用域是一个编译期的概念，也就是说，编译器在编译过程中会对每个标识符的作 用域进行检查，对于在标识符作用域外使用该标识符的行为会给出编译错误的报错。

不过，我们可以使用代码块的概念来划定每个标识符的作用域。这个划定原则是什么呢？ **原则就是声明于外层代码块中的标识符，其作用域包括所有内层代码块。**



## **避免变量遮蔽的原则**

**变量遮蔽问题的根本原因**，就是内层代码块中声明了一个与外层代码块同名且同类型的变 量，这样，内层代码块中的同名变量就会替代那个外层变量，参与此层代码块内的相关计 算，我们也就说内层变量遮蔽了外层同名变量

**出现的几类问题**：

- 第一个问题：遮蔽预定义标识符。
- 第二个问题：遮蔽包代码块中的变量
- 第三个问题：遮蔽外层显式代码块中的变量。



## **利用工具检测变量遮蔽问题**

Go 官方提供了 go vet 工具可以用于对 Go 源码做一系列静态检查，在 Go 1.14 版以前默 认支持变量遮蔽检查，Go 1.14 版之后，变量遮蔽检查的插件就需要我们单独安装了，安 装方法如下：

```go
go install golang.org/x/tools/go/analysis/passes/shadow/cmd/shadow@latest
go: downloading golang.org/x/tools v0.1.5
go: downloading golang.org/x/mod v0.4.2
```

一旦安装成功，我们就可以通过 go vet 扫描代码并检查这里面有没有变量遮蔽的问题了。 我们现在就来检查一下前面的示例代码，看看效果怎么样。执行检查的命令如下：

```go
go vet -vettool=$(which shadow) -strict *****.go
```



# 基本数据类型

## 数值类型

### 整型

#### **整型类型**

整型可以分为**平台无关整型和平台相关整型**这两种，它们的区别主要就在，这些整数类型在不同 CPU 架构或操作系统下面，它们的长度是否是一致的。

> **平台无关整型**

平台无关整型，它们在任何 CPU 架构或任何操作系统下面，长度都是固定不变 的。我在下面这张表中总结了 Go 提供的平台无关整型：

![image-20221111125326903](markdown%E5%9B%BE%E7%89%87/image-20221111125326903.png)

这些平台无关的整型也可以分成两类：有符号整型（int8~int64）和无符号 整型（uint8~uint64）。两者的本质差别在于最高二进制位（bit 位）是否被解释为符号 位，这点会影响到无符号整型与有符号整型的取值范围。

那么-127的二进制码怎么表示：**127的补码来表示，源码取反+1.**

![image-20221111125735874](markdown%E5%9B%BE%E7%89%87/image-20221111125735874.png)



> **平台相关整型**

平台相关整型，它们的长度会根据运行平台的改变而改变。Go 语言原生提供了三个平台相关整型，它们是 int、uint 与 uintptr

要特别注意一点，由于这三个类型的长度是平台相关的，所以我们在**编写有移 植性要求的代码时，千万不要强依赖这些类型的长度**。如果你不知道这三个类型在目标运 行平台上的长度，可以通过 unsafe 包提供的 SizeOf 函数来获取

![image-20221111130016091](markdown%E5%9B%BE%E7%89%87/image-20221111130016091.png)



#### **整型溢出问题**

无论哪种整型，都有它的取值范围，也就是有它可以表示的值边界。如果这个整型因为参 与某个运算，导致结果超出了这个整型的值边界，我们就说发生了**整型溢出**的问题。

由于 整型无法表示它溢出后的那个“结果”，所以出现溢出情况后，对应的整型变量的值依然 会落到它的取值范围内，只是结果值与我们的预期不符，导致程序逻辑出错。

我们**想算出溢出后的值**，应该用二进制来算，如果是有符号的，当遇到符号位为1，就-1取反的操作来算出真实值。

```go
var s int8 = 127
s += 1 // 预期128，实际结果-128
var u uint8 = 1
u -= 2 // 预期-1，实际结果255
```



#### **字面值与格式化输出**

Go 语言在设计开始，就继承了 C 语言关于数值字面值（Number Literal）的语法形式

```go
d1 := 0b10000001 // 二进制，以"0b"为前缀
d2 := 0B10000001 // 二进制，以"0B"为前缀
e1 := 0o700 // 八进制，以"0o"为前缀
e2 := 0O700 // 八进制，以"0O"为前缀
a := 53 // 十进制
b := 0700 // 八进制，以"0"为前缀
c1 := 0xaabbcc // 十六进制，以"0x"为前缀
c2 := 0Xddeeff // 十六进制，以"0X"为前缀

```

```go
var a int8 = 59
fmt.Printf("%b\n", a) //输出二进制：111011
fmt.Printf("%d\n", a) //输出十进制：59
fmt.Printf("%o\n", a) //输出八进制：73
fmt.Printf("%O\n", a) //输出八进制(带0o前缀)：0o73
fmt.Printf("%x\n", a) //输出十六进制(小写)：3b
fmt.Printf("%X\n", a) //输出十六进制(大写)：3B
```



### 浮点型

和使用广泛的整型相比，浮点型的使用场景就相对聚焦了，主要集中在科学数值计算、图 形图像处理和仿真、多媒体游戏以及人工智能等领域。

Go 语言提供了 float32 与 float64 两种浮点类型，它们分别对应的就是 IEEE 754 中的单 精度与双精度浮点数值类型。不过，这里要注意，Go 语言中没有提供 float 类型。这不像 整型那样，Go 既提供了 int16、int32 等类型，又有 int 类型。换句话说，**Go 提供的浮点 类型都是平台无关的。**

无论是 float32 还是 float64，它们的变量的默认值都为 0.0，不同的是它们占用的内存空 间大小是不一样的，可以表示的浮点数的范围与精度也不同。

> **字面值与格式化输出**

Go 浮点类型字面值大体可分为两类，一类是直白地用十进制表示的浮点值形式。这一类， 我们通过字面值就可直接确定它的浮点值

```go
3.1415
.15 // 整数部分如果为0，整数部分可以省略不写
81.80
82. // 小数部分如果为0，小数点后的0可以省略不写
```

另一类则是科学计数法形式。采用科学计数法表示的浮点字面值，我们需要通过一定的换 算才能确定其浮点值。而且在这里，科学计数法形式又分为十进制形式表示的，和十六进 制形式表示的两种。 我们先来看十进制科学计数法形式的浮点数字面值，这里字面值中的 e/E 代表的幂运算的 底数为 10：

```go
6674.28e-2 // 6674.28 * 10^(-2) = 66.742800
.12345E+5 // 0.12345 * 10^5 = 12345.000000
```

fmt 包也提供了针对浮点数的格式化输出。我们 最常使用的格式化输出形式是 %f。通过 %f，我们可以输出浮点数最直观的原值形式。

```go
var f float64 = 123.45678
fmt.Printf("%f\n", f) // 123.456780
```

我们也可以将浮点数输出为科学计数法形式，如下面代码：

```go
fmt.Printf("%e\n", f) // 1.234568e+02
fmt.Printf("%x\n", f) // 0x1.edd3be22e5de1p+06
```

其中 %e 输出的是十进制的科学计数法形式，而 %x 输出的则是十六进制的科学计数法形 式。



### 复数类型

Go 语言则原生支持复数类型。不过，和整型、浮点型相比，复数类型在 Go 中的应用就更为局限和小众，主要用于专业领域的计算，比如矢量计算等。

Go 提供两种复数类型，它们分别是 complex64 和 complex128，complex64 的实部与 虚部都是 float32 类型，而 complex128 的实部与虚部都是 float64 类型。如果一个复数 没有显示赋予类型，那么它的默认类型为 complex128

- 第一种，我们可以通过复数字面值直接初始化一个复数类型变量：

  ```go
  var c = 5 + 6i
  var d = 0o123 + .12345E+5i // 83+12345i
  ```

- 第二种，Go 还提供了 complex 函数，方便我们创建一个 complex128 类型值： 

  ```go
  var c = complex(5, 6) // 5 + 6i
  var d = complex(0o123, .12345E+5) // 83+12345i
  ```

- 第三种，你还可以通过 Go 提供的预定义的函数 real 和 imag，来获取一个复数的实部与 虚部，返回值为一个浮点类型：



### 自定义的数值类型

如果我们要通过 Go 提供的类型定义语法，来创建自定义的数值类型，有两种方法。

1. **type关键字**

我们可以通过 type 关键字基于原生数值类型来声明一个新类型。 但是自定义的数值类型，在和其他类型相互赋值时容易出现一些问题。

比如 `type MyInt int8`，这里，因为 MyInt 类型的底层类型是 int32，所以它的数值性质与 int32 完全相同，但它 们仍然是完全不同的两种类型。根据 Go 的类型安全规则，我们无法直接让它们相互赋 值，或者是把它们放在同一个运算中直接计算，这样编译器就会报错。

```go
var m int = 5
var n int32 = 6
var a MyInt = m // 错误：在赋值中不能将m（int类型）作为MyInt类型使用
var a MyInt = n // 错误：在赋值中不能将n（int32类型）作为MyInt类型使用
```

要避免这个错误，我们需要借助**显式转型**，让赋值操作符左右两边的操作数保持类型一 致



2. **类型别名（Type Alias）**

通过类型别名语法定义的新类型与原类型别无二致，可以 完全**相互替代**.这也属于**Go的一个语法糖**。

```go
type MyInt = int32
var n int32 = 6
var a MyInt = n // ok
```



## 字符串类型

### **why Go原生支持字符串**

C 语言中并没有“字符串”这个数 据类型。在 C 语言中，字符串是以字符串字面值或以’\0’结尾的字符类型数组来呈现的。这样定义的非原生字符串在使用过程中会有很多问题，比如：

- 不是原生类型，编译器不会对它进行类型校验，导致类型安全性差； 
- 字符串操作时要时刻考虑结尾的’\0’，防止缓冲区溢出； 
- 以字符数组形式定义的“字符串”，它的值是可变的，在并发场景中需要考虑同步问 题； 
- 获取一个字符串的长度代价较大，通常是 O(n) 时间复杂度； 
- C 语言没有内置对非 ASCII 字符（如中文字符）的支持。



Go 原生支持 string 的做法是对前辈语言的改进，这样的设计到底有 哪些优秀的性质，会带来什么好处呢？

- **第一点：string 类型的数据是不可变的，提高了字符串的并发安全性和存储利用率。**
- **第二点：没有结尾’\0’，而且获取长度的时间复杂度是常数时间，消除了获取字符串长 度的开销。**
- **第三点：原生支持“所见即所得”的原始字符串，大大降低构造多行字符串时的心智负 担。**
- **第四点：对非 ASCII 字符提供原生支持，消除了源码在不同环境下显示乱码的可能**
  - Go 语言源文件默认采用的是 Unicode 字符集，Unicode 字符集是目前市面上最流行的字 符集，它囊括了几乎所有主流非 ASCII 字符（包括中文字符）。Go 字符串中的每个字符都 是一个 Unicode 字符，并且这些 Unicode 字符是以 UTF-8 编码格式存储在内存当中的。



### **what Go 字符串的组成**

Go 语言在看待 Go 字符串组成这个问题上，有两种视角。

> **字节视角**

也就是和所有 其它支持字符串的主流语言一样，Go 语言中的**字符串值也是一个可空的字节序列，字节序 列中的字节个数称为该字符串的长度。一个个的字节只是孤立数据，不表意**。

```go
var s = "中国人"
fmt.Printf("the length of s = %d\n", len(s)) // 9
for i := 0; i < len(s); i++ {
	fmt.Printf("0x%x ", s[i]) // 0xe4 0xb8 0xad 0xe5 0x9b 0xbd 0xe4 0xba 0xba
}
fmt.Printf("\n")
```

> **字符视角**

如果要表意，我们就需要从字符串的另外一个视角来看，也就是**字符串是由一个可空的字 符序列构成**。

```go

var s = "中国人"
fmt.Println("the character count in s is", utf8.RuneCountInString(s)) // 3
for _, c := range s {
	fmt.Printf("0x%x ", c) // 0x4e2d 0x56fd 0x4eba
}
fmt.Printf("\n")
```

在这段代码中，我们输出了字符串中的字符数量，也输出了这个字符串中的每个字符。前 面说过，Go 采用的是 Unicode 字符集，每个字符都是一个 Unicode 字符，那么这里输出 的 0x4e2d、0x56fd 和 0x4eba 就应该是某种 Unicode 字符的表示了。没错，以 0x4e2d 为例，它是汉字“中”在 Unicode 字符集表中的**码点**



### **rune 类型与字符字面值**

Go **使用 rune 这个类型来表示一个 Unicode 码点**。rune 本质上是 int32 类型的别名类 型，它与 int32 类型是完全等价的

由于一个 Unicode 码点唯一对应一个 Unicode 字符。所以我们可以说，**一个 rune 实例 就是一个 Unicode 字符，一个 Go 字符串也可以被视为 rune 实例的集合**。我们可以通过 字符字面值来初始化一个 rune 变量。

在 Go 中，字符字面值有多种表示法，最常见的是**通过单引号括起的字符字面值**: ` '中' `



### **字符串字面值**

字符串是字符的集合，了解了字符字面值后，字符串的字面值也就很简单了。只不过字符 串是多个字符，所以我们需要把表示单个字符的单引号，换为表示**多个字符组成的字符串 的双引号**就可以了



### **Go 字符串类型的内部表示**

```go
type StringHeader struct {
    Data uintptr
    Len int
}
```

**string 类型其实是一个“描述符”，它本身并不真正存储字符串数据，而 仅是由一个指向底层存储的指针和字符串的长度字段组成的**。

Go 编译器把源码中的 string 类型映射为运行时的一个二元组（Data, Len），真实 的字符串值数据就存储在一个被 Data 指向的底层数组中。通过 Data 字段，我们可以得到 这个数组的内容

我们可以得到这样一个结论，那就是我们**直接将 string 类型通过函数 / 方法参数传入也不会带来太多的开销**。因为传入的仅仅是一个“描 述符”，而不是真正的字符串数据。



### **how Go 字符串类型的常见操作**

Go 为其原生支持的 string 类型提供了许多原生操作类型，在进行字符串操作时你要注意 以下几点：

- 通过常规 for 迭代与 for range 迭代所得到的结果不同，常规 for 迭代采用的是字节视 角；而 for range 迭代采用的是字符视角；
-  基于 +/+= 操作符的字符串连接是对开发者体验最好的字符串连接方式，但却不是性能 最好的方式； 
- 无论是字符串转切片，还是切片转字符串，都会有内存分配的开销，这缘于 Go 字符串 数据内容不可变的性质。

> **下标操作**

在字符串的实现中，真正存储数据的是底层的数组。字符串的下标操作本质上等价于底层 数组的下标操作。我们在前面的代码中实际碰到过针对字符串的下标操作，形式是这样 的：

```go
var s = "中国人"
fmt.Printf("0x%x\n", s[0]) // 0xe4：字符“中” utf-8编码的第一个字节
```

可以看到，通过下标操作，我们获取的是字符串中特定下标上的字节，而不是字符。



> **字符迭代**

Go 有两种迭代形式：常规 for 迭代与 for range 迭代。你要注意，**通过这两种形式的迭代 对字符串进行操作得到的结果是不同的。**

- 通过常规 for 迭代对字符串进行的操作是一种字节视角的迭代，每轮迭代得到的的结果都 是组成字符串内容的一个字节，以及该字节所在的下标值，这也等价于对字符串底层数组 的迭代

- 通过 for range 迭代，我们每轮迭代得到的是字符串中 Unicode 字符的码点 值，以及该字符在字符串中的偏移值。我们可以通过这样的迭代，获取字符串中的**字符个数**，而通过 Go 提供的内置函数 **len**，我们只能获取字符串内容的长度（**字节个数**）。当然 了，获取字符串中字符个数更专业的方法，是调用标准库 UTF-8 包中的 **RuneCountInString 函数**

  

> **字符串连接**

字符串内容是不可变的，但这并不妨碍我们基于已有字符串创建新字 符串。Go 原生支持通过 +/+= 操作符进行字符串连接，这也是对开发者体验最好的字符 串连接操作。虽然通过 +/+= 进行字符串连接的开发体验是最好的，但**连接性能就未必是最快**的 了。

除了这个方法外，Go 还提供了 strings.Builder、strings.Join、fmt.Sprintf、bytes.Buffer 等函数来 进行字符串连接操作。

**strings.Builder的连接是性能最好的**。



首先在strings.Builder前，使用`bytes.Buffer`来优化（**bytes.Buffer是零值可用哦！**）

```go
package main
 
import (
    "bytes"
    "fmt"
)
 
func main() {
    ss := []string{
        "A",
        "B",
        "C",
    }
 
    var b bytes.Buffer
    for _, s := range ss {
        fmt.Fprint(&b, s)
    }
    print(b.String())
}
```

这里使用 `var b bytes.Buffer` 存放最终拼接好的字符串，一定程度上避免上面 `str` 每进行一次拼接操作就重新申请新的内存空间存放中间字符串的问题。**但这里依然有一个小问题： `b.String()` 会有一次 `[]byte -> string` 类型转换。而这个操作是会进行一次内存分配和内容拷贝的。**



使用strings.Builder

```go
package main
 
import (
    "fmt"
    "strings"
)
 
func main() {
    ss := []string{
        "A",
        "B",
        "C",
    }
 
    var b strings.Builder
    for _, s := range ss {
        fmt.Fprint(&b, s)
    }
 
    print(b.String())
}
```

strings.Builder源码

```go
type Builder struct {
    addr *Builder // of receiver, to detect copies by value
    buf  []byte // 1
}
 
// Write appends the contents of p to b's buffer.
// Write always returns len(p), nil.
func (b *Builder) Write(p []byte) (int, error) {
    b.copyCheck()
    b.buf = append(b.buf, p...) // 2
    return len(p), nil
}
 
// String returns the accumulated string.
func (b *Builder) String() string {
    return *(*string)(unsafe.Pointer(&b.buf))  // 3
}
 
func (b *Builder) copyCheck() {
    if b.addr == nil {
        b.addr = (*Builder)(noescape(unsafe.Pointer(b)))
    } else if b.addr != b {
        panic("strings: illegal use of non-zero Builder copied by value")
    }
}
 
```

- **与`byte.Buffer`思路类似，既然 string 在构建过程中会不断的被销毁重建，那么就尽量避免这个问题，底层使用一个 `buf []byte` 来存放字符串的内容。**
- **对于写操作，就是简单的将byte写入到 buf 即可。**

- **为了解决`bytes.Buffer.String()`存在的`[]byte -> string`类型转换和内存拷贝问题，这里使用了一个`unsafe.Pointer`的存指针转换操作，实现了直接将`buf []byte`转换为 string类型，同时避免了内存充分配的问题。**

- **如果我们自己来实现strings.Builder, 大部分情况下我们完成前3步就觉得大功告成了。但是标准库做得要更近一步。我们知道Golang的堆栈在大部分情况下是不需要开发者关注的，如果能够在栈上完成的工作逃逸到了堆上，性能就大打折扣了。因此，`copyCheck` 加入了一行比较hack的代码来避免buf逃逸到堆上。**



> **字符串比较**

Go 字符串类型支持各种比较关系操作符，包括 = =、!= 、>=、<=、> 和 <。在字符串 的比较上，Go 采用字典序的比较策略，分别从每个字符串的起始处，开始**逐个字节**地对两 个字符串类型变量进行比较。



> **字符串转换**

Go 支持字符串与字节切片、字符串与 rune 切片的双向转换，并且这种转换无 需调用任何函数，只需使用显式类型转换就可以了。

这样的转型看似简单，但无论是 string 转切片，还是切片转 string，这类转型背后也是有 着一定开销的。这些开销的根源就在于 string 是不可变的，运行时要为转换后的类型分配 新内存。

- 转换开销小的方法是：借助unsafe.Pointer类型。

```go
func string2bytes(s string) []byte{
	return *(*[]byte)(unsafe.Pointer(&s))
}
func bytes2string(b []byte) string {
	return *(*string)(unsafe.Pointer(&b))
}
```

- 也可以用**for range来避免内存分配来提高性能`for i, v := range []byte(str){}`**因为`range 对象`这个对象是**临时分配的副本！！！**



# 常量

Go 原生支持的基本数据类型，包括数值类型与字 符串类型。这两类基本数据类型不仅仅可以被用来声明变量、明确变量绑定的内存块边 界，还可以被用来定义另外一大类语法元素：**常量**

## **常量以及 Go 原生支持常量的好处**

Go 语言的常量是一种在**源码编译期间被创建**的语法元素。这是在说这个元素的值可以像变 量那样被初始化，但它的初始化表达式必须是**在编译期间可以求出值来的**。而且，Go 常量一旦声明并被初始化后，它的值在整个程序的生命周期内便保持不变。

Go 是使用 var 关键字声明变量的。在常量这里，Go 语言引入 **const** 关键 字来声明常量。和 var 支持单行声明多个变量，以及以代码块形式聚合变量声明一 样，const 也支持单行声明多个常量，以及以代码块形式聚合常量声明的形式。

Go 语言规范规定，Go 常量的类型只局限于前面我们学过的 Go 基本数据类型，包 括数值类型、字符串类型，以及只有两个取值（true 和 false）的布尔类型。



## **创新点**

> **无类型常量**

**Go 语言对类型安全是有严格要求的：即便两个类型拥有着相 同的底层类型，但它们仍然是不同的数据类型，不可以被相互比较或混在一个表达式中进 行运算。**这一要求不仅仅适用于变量，也同样适用于有类型常量（Typed Constant）中

```go
type myInt int
const n myInt = 13
const m int = n + 5 // 编译器报错：cannot use n + 5 (type myInt) as type int in
func main() {
    var a int = 5
    fmt.Println(a + n) // 编译器报错：invalid operation: a + n (mismatched types
}
```

有类型常量与变量混合在一起进行运算求值的时候，也必须遵守类型相同这一要 求，否则我们只能通过显式转型才能让上面代码正常工作

```go
type myInt int
const n myInt = 13
const m int = int(n) + 5 // OK
func main() {
    var a int = 5
    fmt.Println(a + int(n)) // 输出：18
}

```

还一种解决办法是：**无类型常量**

```go
type myInt int
const n = 13
func main() {
	var a myInt = 5
	fmt.Println(a + n) // 输出：18
}

```

不过，**无类型常量也不是说就真的没有类型**，它也有自己的默认类型，不过它的默认类型 是根据它的初值形式来决定的。像上面代码中的常量 n 的初值为整数形式，所以它的默认 类型为 int。

**发现问题了**：常量 n 的默认类型 int 与 myInt 并不是同一个类 型啊，为什么可以放在一个表达式中计算而没有报编译错误呢？隐式转换。



> **隐式转型**

隐式转型说的就是，**对于无类型常量参与的表达式求值，Go 编译器会根据上下文中的类型 信息，把无类型常量自动转换为相应的类型后，再参与求值计算，这一转型动作是隐式进 行的。**但由于转型的对象是一个常量，所以这并不会引发类型安全问题，Go 编译器会保证 这一转型的安全性。



> **实现枚举**

**Go 语言其实并没有原生提供枚举类型。**

Go 设计者们的原创，他们在语 言设计之初就希望**将枚举类型与常量合二为一**，这样就不需要再单独提供枚举类型了，于 是他们将 Go 的前辈 C 语言中的枚举类型特性移植到常量的特性中并进行了“改良”。

**两个重要特性实现枚举**：

- **自动重复上一行**：Go 的 **const 语法提供了“隐式重复前一个非空 表达式”的机制**

  ```go
  const (
  Apple, Banana = 11, 22
  strawberry, Grape
  )
  //等价于
  const (
  Apple, Banana = 11, 22
  strawberry, Grape = 11, 22
  )
  ```

- **引入 const 块中的行偏移量指 示器 iota**：iota 是 Go 语言的一个预定义标识符，它表示的是 **const 声明块（包括单行声明）中，每 个常量所处位置在块中的偏移值**（**从零开始**）。同时，**每一行中的 iota（要提醒你的是， 位于同一行的 iota 即便出现多次，多个 iota 的值也是一样的）** **自身也是一个无类 型常量**，可以像前面我们提到的无类型常量那样，自动参与到不同类型的求值过程中来， 不需要我们再对它进行显式转型操作。

  **每个 iota 的生命周期**都始于一个 const 代码块的开始，在该 const 代码块结 束时结束。在每一个**const关键字**出现时，重置为0（**隐形成长，看你什么时候用它**）

  ```go
  const (
  	Apple, Banana = iota, iota + 10 // 0, 10 (iota = 0)
  	Strawberry, Grape // 1, 11 (iota = 1)
  	Pear, Watermelon // 2, 12 (iota = 2)
  )
  ```



# 复合类型

由多个**同构类型**（相同类型）或**异构类型**（不同类型）的元素的值组合而成的。这类 数据类型在 Go 语言中被称为复合类型。

## 数组

### **基本特性**

Go 语言的数组是一个长度固定的、由同构类型元素组成的连 续序列。Go 的数组类型包含两个重要属性：**元素的类型 和数组长度（元素的个数）**。这两个属性也直接构成了 Go 语言中数组类型变量的声明：`var arr [N]Type`.

数 组的长度必须在声明数组变量时提供，Go 编译器需要在编译阶段就知道数组类型的长度， 所以，我们只能用整型数字面值或常量表达式作为 N 值。

**如果两个数组类型的元素类型 T 与数组长度 N 都是一样 的，那么这两个数组类型是等价的，如果有一个属性不同，它们就是两个不同的数组类 型。**

Go 提供了预定义函数 len 可以用于获取一 个数组类型变量的长度，通过 unsafe 包提供的 Sizeof 函数，我们可以获得一个数组变量 的总大小

```go
var arr = [6]int{1, 2, 3, 4, 5, 6}
fmt.Println("数组长度：", len(arr)) // 6
fmt.Println("数组大小：", unsafe.Sizeof(arr)) // 48
```



### **初始化**

1. **零值初始化**：不进行显式初始化，那么数组中的元素值就是它类型的零值

2. **显式初始化：**需要在右值中显式放置数组类型，并通过大括号的方式 给各个元素赋值（如下面代码中的 arr2）。当然，我们也可以忽略掉右值初始化表达式中 数组类型的长度，用“…”替代，Go 编译器会根据数组元素的个数，自动计算出数组长度

   - 如果我们要对一个长度较大的稀疏数组进行显式初始化，这样逐一赋值就太麻烦了，还 有什么更好的方法吗？我们可以通过使用下标赋值的方式对它进行初始化

     ```go
     var arr4 = [...]int{
     99: 39, // 将第100个元素(下标值为99)的值赋值为39，其余元素值均为0
     }
     fmt.Printf("%T\n", arr4) // [100]int
     ```
     
     

### **数组存在的问题**

无论 是参与迭代，还是作为实际参数传给一个函数 / 方法，Go 传递数组的方式都是纯粹的值拷 贝，这会带来较大的内存拷贝开销。

解决办法：

- 指针数组方式
- **切片**



## 切片slice

### **内部实现**

Go 切片在运行时其实是一个三元组结构

```go
type slice struct {
    array unsafe.Pointer //指向底层数组的指针
    len int  //是切片的长度，即切片中当前元素的个数
    cap int //是底层数组的长度，也是切片的最大容量，cap 值永远大于等于 len 值
}
```

**Go 编译器会自动为每个新创建的切片，建立一个属于它的底层数组**，默认底层数组的长 度与切片初始元素个数相同。其实可以看出切片是对底层数组的引用，所以是**引用类型数据**，必须通过显示初始化才能分配内存使用。当然这里**零值初始化的nil切片也可以直接用append添加元素**。

**零值可用类型**：Go语言零值可用理念给内置类型、标准库的使用带来很多便利。比如切片的的append操作、nil指针调用、bytes.Buffer()、sync.Mutex()、string的使用。但也有一定限制

- 切片append场景下不能用来操作下标
- map不支持零值可用
- 零值可用避免值的复制，可以通过指针传递。



### 声明创建

我们还可以用以下几种方法创建切片，并指定它底层数组的 长度。

1. **方法一：通过 make 函数来创建切片，并指定底层数组的长度**

   **尽量使用cap参数创建切片**：append重新分配底层数组开销大，提前预估切片容量规模，性能会比较好。

   ```go
   sl := make([]byte, 6, 10) // 其中10为cap值，即底层数组长度，6为切片的初始长度
   sl := make([]byte, 6) // cap = len = 6
   ```

2. **方法二：采用 array[low : high : max]语法基于一个已存在的数组创建切片。这种方式被 称为数组的切片化**

   ```go
   arr := [10]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
   sl := arr[3:7:9]
   ```

   它的起始元素从 low 所标识的下标值开始，切片的长度 （len）是 high - low，它的容量是 max - low.

   而且，由于切片 sl 的底层数组就是数组 arr，对切片 sl 中元素的修改将直接影响数组 arr 变量。这样看来，**切片好比打开了一个访问与修改数组的“窗口”**，通过这个窗口，我们可以直 接操作底层数组中的部分元素。这有些类似于我们操作文件之前打开的“文件描述 符”（Windows 上称为句柄），通过文件描述符我们可以对底层的真实文件进行相关操 作。**可以说，切片之于数组就像是文件描述符之于文件。**

   也正是**因为这一特性，切片才能在函数参数传递时避免较大性能开销**。因 为我们传递的并不是数组本身，而是数组的“描述符”，而这个描述符的大小是固定的 （见上面的三元组结构），无论底层的数组有多大，切片打开的“窗口”长度有多长，它 都是不变的。此外，我**们在进行数组切片化的时候，通常省略 max，而 max 的默认值为 数组的长度。**

   另外，针对一个已存在的数组，我们还可以建立多个操作数组的切片，**这些切片共享同一 底层数组**，切片对底层数组的操作也同样会反映到其他切片中

3. **方法三：基于切片创建切片**。



**重点**：**nil切片和空切片区别**

- 切片是引用类型不能比较，只能判断是否为nil切片。
- nil切片和空切片（显式初始化为空）长度和容量都为0，只不过nil切片没有底层数组。
- **所有的空切片底层数组地址一样struct{某一共同地址，0，0}**



### **切片的动态扩容**

**“动态扩容”**指的就是，当我们通过 append 操作向切片追加数据的时候，如果这时切片 的 len 值和 cap 值是相等的，也就是说切片底层数组已经没有空闲空间再来存储追加的值了，**Go 运行时**就会对这个切片做扩容操作，来保证切片始终能存储下追加的新值。

- **如果需要的最小容量比两倍原有容量大，那么就取需要的容量**(所以这里不一定是最终值，**还有内存对齐操作**)
- 如果原有 slice 长度小于 1024 ,那么每次就扩容为原来的两倍
- 如果原 slice 大于等于 1024, 那么每次扩容就扩为原来的 1.25 倍
- **除此之外扩容容量计算完成之后，还会进行一次内存对齐操作**（一定要走到第四步）



**扩容后：**扩容后slice:  Go 默认会先开⼀⽚内存区域，把原来的值拷⻉过来，然 后再执⾏ append()操作，产生新的底层数组和与之对应的slice。这种情况丝毫不影响原底层数组及原slice，会被GC。所以：**每个slice对应的底层数组永远不会被替换，copy函数也是这个道理**



### **基本操作**

1. **求长度和容量**：len()函数和cap函数



2. **比较**

   - **反射：**reflect.DeepEqual(a, b)，影响程序性能

   - **遍历：**
     - 先比较长度是否相等，`否`则`false`；
     - 再比较两个slice是否都为nil或都不为nil，`否`则`false`；一定要判断！！！与反射判断机制对应
     - 再比较对应索引处两个slice的元素是否相等，`否`则`false`；前面都为`是`则`true`



3. **添加append**

- append函数的实现就是接受一个空接口的参数，然后插入切片(需要解引用)
- append允许零值初始化可用就是也提前申请了内存



4. **复制**

   - 只要切片在内存中，数组就不能被垃圾回收。如果有一个非常大的数组，只想处理小部分，用切片的话底层数组还是在那里那么大。可以用copy函数，生成一个切片副本。产生新的底层数组新的切片，原始数组被垃圾回收。
   - `copy(dst, src)`

   

5. **删除**

   - 删除的**实质是底层数组在如何变化**
   - 也是用append：`a = append(a[:index], a[index+1:]...)`



6. **作为函数传参**
   - 值传递，复制的是切片。因此相同的是底层数组地址，不同的是切片地址。因此函数内做的更改在函数外可见，因为底层数组可能改变了。
   
   - 想改变切片本身：可以通过传递切片指针和返回切片。
   
   - 在函数里**赋值**：会改变底层数组
   
   - 在函数里**删除**：
   
     - 当需要对slice做删除时，由于需要更改长度字段，**值拷贝就不行了**，需要传slice本身在内存中的地址。
   
     - 但是这里也有可能改变外面的切片,因为你终究改变了底层数组
   
       ```go
       //删除
       [1 2 3 4 5 6 7 8 9]  len 9 
       [1 2 3 5 6 7 8 9 9]  len 9 
       ```
   
   - 在函数里**append，有可能会更改地址**：
     1）添加的数据元素长度超过切片参数的容量，则会**另开辟空间，重新分配底层数组**，并复制数据。函数中的此切片与原切片地址不同； 此切片指向新开辟的内存。函数运行结束，内存释放，**不会影响原切片的内容**。
     2）否则原切片与函数中的切片指向同一地址。**会影响切片的内容**。



## map

map 是我们既切片之后，学到的第二个由 Go 编译器与运行时联合实现的复合数据类型， 它有着复杂的内部实现。

### **什么是 map 类型**

map 是表示一组**无序**的**键值对**。使用 key 和 value 分别代表 map 的键和值。key 与 value 的类型可以相同，也可以不同。要**注意**，map 类型对 value 的类型没有限制，但是对 key 的类型却有严格要 求，因为 **map 类型要保证 key 的唯一性**。Go 语言中要求，**key 的类型必须支 持“==”和“!=”两种比较操作符**。

**重点**：在 Go 语言中，函数类型、map 类型自身，以及切片只支持与 nil 的比较，而不支持同类型两个变量的比较。要注意：**函数类型、map 类型自身，以及切片类型是不能作为 map 的 key 类型的。**

**注意点**：这里用struct类型作为key有坑，因为如果struct的某个字段只修改了，查询map也失败。因此struct作为key要保证struct对象逻辑上不可变。



### **map变量的声明和初始化**

> **声明**

`var m map[string]int`

- 相同点：和切片类型变量一样，如果我们没有显式地赋予 map 变量初值，map 类型变量的默认值 为 nil。

- 不同点：

  - 初值为零值 nil 的切片类型变量，可以借助 内置的 append 的函数进行操作，这种在 Go 语言中被称为“**零值可用”**。定义“零值可 用”的类型，可以提升我们开发者的使用体验，我们不用再担心变量的初始状态是否有 效。 但 map 类型，因为它内部实现的复杂性，无法“零值可用”。

    **重点**：**零值可用类型有slice、sync.Mutex 和 bytes.Buffer**

  - 如果我们对处于零值 状态的 map 变量直接进行操作，就会导致运行时异常（panic），从而导致程序进程异常 退出： 所以，我们必须对 map 类型变量进行显式初始化后才能使用



> **初始化**

- **方法一：使用复合字面值初始化 map 类型变量**

  ```go
  m := map[int]string{}
  m1 := map[int][]string{
      1: []string{"val1_1", "val1_2"},
      3: []string{"val3_1", "val3_2", "val3_3"},
      7: []string{"val7_1"},
  }
  m1 := map[int][]string{
      []string{"val1_1", "val1_2"},
     []string{"val3_1", "val3_2", "val3_3"},
      7: []string{"val7_1"},
  }
  type Position struct {
      x float64
      y float64
  }
  m2 := map[Position]string{
      Position{29.935523, 52.568915}: "school",
      Position{25.352594, 113.304361}: "shopping-mall",
      Position{73.224455, 111.804306}: "hospital",
  }
  
  ```

  Go 提供了“语法糖”。Go 允许省略字面值中的元素 类型。因为 map 类型表示中包含了 key 和 value 的元素类型，Go 编译器已经有足够的信 息，来推导出字面值中各个值的类型了。

  ```go
  type Position struct {
      x float64
      y float64
  }
  m2 := map[Position]string{
      {29.935523, 52.568915}: "school",
      {25.352594, 113.304361}: "shopping-mall",
      {73.224455, 111.804306}: "hospital",
  }
  ```



- **方法二：使用 make 为 map 类型变量进行显式初始化。**

  ```go
  m1 := make(map[int]string) // 未指定初始容量
  m2 := make(map[int]string, 8) // 指定初始容量为8
  ```

  不过，map 类型的容量不会受限于它的初始容量值，当其中的键值对数量超过初始容量 后，Go 运行时会自动增加 map 类型的容量，保证后续键值对的正常插入。
  
  **尽量使用cap参数创建map**：提升map平均访问性能，减少频繁扩容带来的不必要损耗。



### **基本操作**

1. **插入**

```go
m := make(map[int]string)
m[1] = "value1"
m[2] = "value2"
m[3] = "value3"
```

- 不需要自己判断数据有没有插入成功，因为 Go 会保证插入总是成功的。这 里，Go 运行时会负责 map 变量内部的内存管理，因此除非是系统内存耗尽，我们可以不 用担心向 map 中插入新数据的数量和执行结果

- 如果我们插入新键值对的时候，某个 key 已经存在于 map 中了，那我们的插入操 作就会用新值覆盖旧值



2. **获取键值对对数**：内置函数 len()，获取当前变量已经存储的键值 对数量

**注意点**：我们不能对 map 类型变量调用 cap，来获取当前容量，这是 map 类型与切片类型的一个不同点。

 

3. **查找和数据读取**

**在 Go 语言中，请使用“comma ok”惯用法对 map 进行键查找 和键值读取操作。**

```go
m := make(map[string]int)
v, ok := m["key1"]
if !ok {
// "key1"不在map中
}
// "key1"在map中，v将被赋予"key1"键对应的value
```



4. **删除数据**

借助**内置函数 delete** 来从 map 中删除数据。使用 delete 函数的情况下，传入的第一个参数是我们的 map 类型变量，第二个参数就是我们想要删除的键。

**注意点**：delete 函数是从 map 中删除键的唯一方法。即便传给 delete 的键在 map 中并不存在，delete 函数的执行也不会失败，更不会抛出运行时的异常



5. **遍历数据**

在 Go 中，遍历 map 的键值对只有一种方法， 那就是**像对待切片那样通过 for range 语句对 map 数据进行遍历。**

```go
for k, v := range m {
	fmt.Printf("[%d, %d] ", k, v)
}
```

**注意点：** **对同一 map 做多次遍历的时候，每次遍历元素的次序都不相同。**这是 Go 语言 map 类型的一个重要特点，也是很容易让 Go 初学者掉入坑中的一个地方。所以这里 你一定要记住：程序逻辑千万不要依赖遍历 map 所得到的的元素次序。



6. **作为函数参数**

和切片类型一样，**map 也是引用类型**。这就意味着 map 类型变量作为参数被传递给函数 或方法的时候，实质上传递的只是一个“描述符”，而不是整个 map 的数据拷贝，所以这个传递的开销是固定的，而且也很小。 

并且，当 map 变量被传递到函数或方法内部后，我们在函数内部对 map 类型参数的修改 在函数外部也是可见的。



### **内部实现原理**

Go 运行时使用一张哈希表来实现抽象的 map 类型。运行时实现了 map 类型操作的所有功能，包括查找、插入、删除等。

在**编译** 阶段，Go 编译器会将 Go 语法层面的 map 操作，重写成**运行时**对应的函数调用。

```go
// 创建map类型变量实例
m := make(map[keyType]valType, capacityhint) → m := runtime.makemap(maptype, c
// 插入新键值对或给键重新赋值
m["key"] = "value" → v := runtime.mapassign(maptype, m, "key") v是用于后续存储val
// 获取某键的值
v := m["key"] → v := runtime.mapaccess1(maptype, m, "key")
v, ok := m["key"] → v, ok := runtime.mapaccess2(maptype, m, "key")
// 删除某键
delete(m, "key") → runtime.mapdelete(maptype, m, “key”)
```

1. **初始状态**

**hmap** :与语法层面 map 类型变量（m）一一对应的是 runtime.hmap 的 实例。hmap 类型是 map 类型的头部结构（header），也就是我们前面在讲解 map 类型 变量传递开销时提到的 map 类型的描述符，它存储了后续 map 类型操作所需的所有信 息，包括：

![image-20221112161438054](markdown%E5%9B%BE%E7%89%87/image-20221112161438054.png)

**B**： 是 buckets 数组的长度的对数， 即 **bucket 数组的长度是 2^B**。**bucket 的本质上是一个指针**，指向了一片内存空间。

**bmap**: **编译期间会给它加料，动态地创建一个新的结构**，**bmap** 就是我们常说的**“桶”的底层数据结构**。 一个桶中可以存放最多 8 个 key/value, map 使用 hash 函数 得到 hash 值根 据 hmap中 B的值（即hash值得后B位）决定分配到哪个桶， 然后又会根据 hash 值的高 8 位来寻找放在桶的哪个位置 。当某个 bucket（比如 buckets[0]) 的 8 个空槽 slot）都填满了，且 map 尚未达到扩容的 条件的情况下，运行时会建立 overflow bucket，并将这个 overflow bucket 挂在上面 bucket（如 buckets[0]）末尾的 overflow 指针上，这样两个 buckets 形成了一个链表结 构，直到下一次 map 扩容之前，这个结构都会一直存在。

**数据结构**：哈希查找表

**碰撞处理法（冲突解决方式）**：链表法



2. **查询过程**

Go语⾔中 map采⽤的是**哈希查找表**，由⼀个 key 通过哈希函数得到哈希值，64 位系统中就⽣成⼀个64bit 的哈希 值，由这个哈希值将 key 对应到不同的桶 bucket）中，当有多个哈希映射到相同的的桶中时，使⽤链表解决哈希冲突, 桶里面最多装8个键值对，如果有第九个键值对落入当前桶，则要构建一个桶并用overflow指针（overflow bucket）连接起来，这就是**链表法**。

key 经过 hash 后共64 位，根 据 hmap中 B的值，计算它到底要 落在哪个桶时，桶的数量为2^B，如 B=5，那么⽤64 位最后5 位表示第⼏号 桶。在⽤ hash 值的⾼8 位确定在 bucket 中的存储位置（也就是确定哪个桶后再确定在桶的哪里槽位），当前 bmap中的 bucket 未找到，则查询对应的 overflow bucket，对应位置有数据则对⽐完整的哈希值，确定是否是要查找的数据。 

如果两个不同的 key 落在的同⼀个桶上，hash 冲突使⽤链表法接近，遍历 bucket 中的 key 如果当前处于 map进 ⾏了扩容，处于数据搬移状态，则优先从 oldbuckets 查找。



3. **key的支持判等性**

因为**映射过程的第一步就是：把键值转换为哈希值**，字典不会独立存储任何键的值，但会独立存储它们的哈希值。Go 语言一旦定位到了某一个哈希桶，那么就会试图在这个桶中查找键值。具体是怎么找的呢？

- 首先，每个哈希桶都会把自己包含的所有键的哈希值存起来。Go 语言会用被查找键的哈希值与这些哈希值逐个对比，看看是否有相等的。如果一个相等的都没有，那么就说明这个桶中没有要查找的键值，这时 Go 语言就会立刻返回结果了。
- 如果有相等的，那就再用键值本身去对比一次。为什么还要对比？原因是，不同值的哈希值是可能相同的。这有个术语，叫做“哈希碰撞”。

​		所以，**即使哈希值一样，键值也不一定一样。如果键类型的值之间无法判断相等，那么此时这个映射的过程就没办法继续下去了。最后，只有键的哈希值和键值都相等，才能说明查找到了匹配的键 - 元素对**



4. **key的无序性**

随着map中key数量增加，map发生扩容，会发生key的搬迁，原来落在同一个bucket中的key，可能会分离搬迁到其他bucket。而遍历的过程则是按顺序遍历bucket同时按顺序遍历bucket中的cell。搬迁后的key位置发生了重大变化，因此再次遍历map的结果就不可能按照原来的顺序了。



**重点**：考虑到 map 可以自动扩容，map 中数据元素的 value 位置可能在这一 过程中发生变化，所以 **Go 不允许获取 map 中 value 的地址，这个约束是在编译期间就 生效的。** 因此对value元素赋值的操作也需要小心：

**有两种修改方式：**

```
tmpStudent := list["student"]
tmpStudent.Name = "LDB"
list["student"] = tmpStudent
```

**修改该副本，然后再次发生一次值拷贝复制回去**；两次值拷贝，性能差

```
list["student"] = &student
list["student"].Name = "LDB"
```

这样，我们实际上每次修改的都是指针所指向的Student空间，指针本身是常指针，不能修改，`只读`属性，但是指向的Student是可以随便修改的，而且这里并不需要值拷贝。只是一个指针的赋值



5. **map与并发**

从上面的实现原理来看，充当 map 描述符角色的 **hmap 实例自身是有状态的（hmap.flags）**，而且对状态的读写是没有并发保护的。所以说 map 实例不是并发写安全的，也不支持并发读写。如果我们对 map 实例进行并发读写，程序运 行时就会抛出异常。

Go 1.9 版本中引入了支持 并发写安全的 **sync.Map 类型**，可以用来在并发读写的场景下替换掉 map。



6. **map扩容**

**map容量**：不同于 array,slice,channel求容量用cap,**求map容量只能len()**

- **map扩容**：当插入 元素个数超出一定数值后，map 一定会存在自动扩容的问题，也就是怎么扩充 bucket 的 数量，并重新在 bucket 间均衡分配数据的问题。Go 运行时的 map 实现中引入了一个 LoadFactor
- **触发条件**：
  - 当 count > LoadFactor * 2^B （负载因子，目前设置为6.5）(**触发增量扩容**)
  - overflow bucket 过多 时，运行时会自动对 map 进行扩容：当 B 小于 15，也就是 bucket 总数 2^B 小于 2^15 时，如果 overflow 的 bucket 数量超过 2^B；当 B >= 15，也就是 bucket 总数 2^B 大于等于 2^15，如果 overflow 的 bucket 数量超过 2^15。（**触发等量扩容**）
- **解决⽅法**：
  - **go中map采用双倍扩容**：将B加1，即bucket总数2的B次方会变成原来的两倍。就有了新老bucket，注意此时元素都在老bucket,还没有迁移。只有在插入，修改，删除key的时候才会进行真正的搬迁。即最大容量变为原来俩倍。
  - 等量扩容：重新排列，极端下，重新排列也解决不了，map成了链表，性能⼤⼤降低，此时哈希种⼦ hash0 的设置，可以降低此类极端场景的发⽣。



## 结构体

### **如何自定义一个新类型**

> **第一种方法：类型定义**

```go
 type T S // 定义一个新类型T
```

**注意点**：这里的新类型只存在在编译器

引入一个新概念: **底层类型**。

如果一个新类型是基于某个 Go 原生类型定义的， 那么我们就叫 Go 原生类型为新类型的底层类型,比如`type wk int`,新类型`wk`的底层类型就是`int`

那如果不是基于 Go 原生类型定义的新类型，比如 T2，它的底层类型是什么呢？这时我们 就要看它定义时是基于什么类型了。这里，T2 是基于 T1 类型创建的，那么 T2 类型的底 层类型就是 T1 的底层类型，而 T1 的底层类型我们已经知道了，是类型 int，那么 T2 的底 层类型也是类型 int。

**底层类型**:  在 Go 语言中有重要作用，它被用 来判断两个类型本质上是否相同（Identical）。**本质上相同的两个类型，它们的变量可以通过显式转型进行相互 赋值，相反，如果本质上是不同的两个类型，它们的变量间连显式转型都不可能，更不要 说相互赋值了。**



> **第二种方法：类型别名**

这种类型定义方式通常用在 项目的渐进式**重构，**还有对已有包的二次封装方面。

```go
type byte=uint8
type rune=int32
```

类型别名并没有定义出新 类型，类 T 与 S 实际上就是同一种类型，它们只是一种类型的两个名字罢了。



### **如何定义一个结构体类型**

> **通用方法：通过类型字面值来定义**

```go
type Book struct {
    Title string // 书名
    Pages int // 书的页数
    Indexes map[string]int // 书的索引
}
```

**注意点**：

- 可以用"_"标识符作为结构体类型定义中的字段名称。那么这个字段不能被外部包引用，甚至无法被结构体所在的包使用。
- 结构体中字段大写开头表示可公开访问，小写表示私有仅在定义当前结构体包中可访问。



> **结构体比较问题**：

- 如果结构体的所有**成员变量都是可比较的，结构体再来谈比较问题**。不可比较变量：slice, map，func，会编译出错，可以用reflect.DeepEqual来比较这种嵌套不可比较的变量类型。

- **结构体相等（属性名，属性类型，属性个数，属性顺序**），否则会编译出错

- 如果两个不同的struct的实例比较，需要先进行结构体类型转换才可以比较。转换条件：要具备相同的成员（字段名，字段类型，字段个数）

- 如果是**结构体的指针，此时编译不会出错**，因为此时实际上相当于在比较两个指针类型的变量（此时区分房间号和房间内容）

```go
type Student struct {
    Name string
}
func main() {
    fmt.Println(&Student{Name: "menglu"} == &Student{Name: "menglu"})//false，内容相同，但肯定地址不一样
    fmt.Println(Student{Name: "menglu"} == Student{Name: "menglu"})//true
}
```



> **特殊定义方法一：空结构体**

```go
type Empty struct{}
```

**俩个用处**：

- 空结构体内存占用为0。在日常开发中，作为一种“事件”信息进行Goroutine之间的通信。
- set的实现：`map[interface{}]bool 或者 map[interface{}]struct{}`



> **特殊定义方法二：嵌套结构体(继承或组合)**

**直接嵌套（组合）**：

```go
type T1 struct{
}
type T2 struct{
    t T1
}
```



**嵌入字段(匿名字段、继承)：**

```go
type T1 struct{
}
type T2 struct{
    T1
}
```

**嵌入字段**（Embedded Field）。我们也可以将这 种字段称为**匿名字段**，或者把类型名看作是这个字段的名字。**我们可以无需提供字段的名字，只需要使用其类型就可以了**



> **组合和继承**：

```go
// 父结构体
type BaseController struct {
}
// 父结构体的方法
func (c *BaseController) ReturnJson() {
}
// 继承
type UserController struct {
	BaseController
}
// 组合
type OtherController struct {
	userController UserController
}

// 调用
user := UserController{}
other := OtherController{}
user.ReturnJson()  //继承直接调用父结构体方法
other.userController.ReturnJson() //组合调用结构体方法
```





### **结构体变量的声明及初始化**

> **零值初始化**

Go 结构体类型由若干个字段组成，当这个结构体类型变量的各个字段的值都是 零值时，我们就说这个结构体类型变量处于零值状态。

**结构体类型的变量通常都要被赋予 适当的初始值后，才会有合理的意义。**也就是结构体不是**零值可用类型**



> **使用复合字面值**

**按顺序依次给每个结构体字段进行赋 值：**

```go
type Book struct {
    Title string // 书名
    Pages int // 书的页数
    Indexes map[string]int // 书的索引
}
var book = Book{"The Go Programming Language", 700, make(map[string]int)}
```



**“field:value”形式的复合字面值**

```go
var t = T{
    F2: "hello",
    F1: 11,
    F4: 14,
}
```

**注意点**：我们不能用从其他包导入的结构体中的未导出字段，来作为复合 字面值中的 field。这会导致编译错误，因为未导出字段是不可见的。 那么，如果一个结构体类型中包含未导出字段，并且这个字段的零值还不可用时，我们要 如何初始化这个结构体类型的变量呢？又或是一个结构体类型中的某些字段，需要一个复 杂的初始化逻辑，我们又该怎么做呢？这时我们就需要使用一个特定的构造函数，来创建 并初始化结构体变量了



> **使用特定的构造函数**

```go
func NewT(field1, field2, ...) *T {
... ...
}
```



### **结构体类型的内存布局**

> **理想状态**：

![image-20221112182751145](markdown%E5%9B%BE%E7%89%87/image-20221112182751145.png)

可以借助标准库 unsafe 包提供的函数，获 得结构体类型变量占用的内存大小，以及它每个字段在内存中相对于结构体变量起始地址 的偏移量:

```go
var t T
unsafe.Sizeof(t) // 结构体类型变量占用的内存大小
unsafe.Offsetof(t.Fn) // 字段Fn在内存中相对于变量t起始地址的偏移量
```



> **真实状态**：

![image-20221112182910776](markdown%E5%9B%BE%E7%89%87/image-20221112182910776.png)

在真实情况下，虽然 Go 编译器没有在结构体变量占用的内存空间中插入额外字段，但结 构体字段实际上可能并不是紧密相连的，中间可能存在“缝隙”。这些“缝隙”同样是结 构体变量占用的内存空间的一部分，它们是 Go 编译器插入的“填充物（Padding）”

**填充物**：这其实是内存对齐的要 求。所谓**内存对齐**，指的就是各种内存对象的内存地址不是随意确定的，必须满足特定要 求。



> **内存对齐计算步骤**：

- 获得对齐系数，64bit系统对齐系数8，32bit系统对齐系数4
- 第一个阶段是对齐结构体的各个字段
- 第二个阶段，也就是对齐整个结构体

```go
type T struct {
    b byte
    u uint16
    i int64
}
```

第一阶段：sum=1+7+8+2

第二阶段：x= min(结构体最长字段的长度，系统内存对齐系 数）=min(8,8)=8; sum = 1+7+8+2+6



### **结构体的json序列化**

**Json序列化**指，将具有key-value(键 -> 值)结构的数据类型，例如：go语言中的map, slice，struct...序列化成json格式的字符串的操

Json是一种主流的数据传输格式，灵活轻便。Json键值对用来保存Js对象的一种方式，键值对组合中的键名。



# 指针

> ## 什么是指针类型

和我们学过的所有类型都不同，**指针类型是依托某一个类型而存在的**，比如：一个整型为 int，那么它对应的整型指针就是 *int，也就是在 int 的前面加上一个星号。没有 int 类型，就不会有 *int 类型。而 int 也被称为 *int 指针类型的**基类型**。



**泛化一下指针类型的这个定义：如果我们拥有一个类型 T，那么以 T 作为基类型的指针类型为 *T。**

声明形式：`var p *T`

如果指针类型变量没有被显式赋予初值，那么它的值为 nil

```go
var p *T
println(p == nil) // true
```

如果要给一个指针类型变量赋值，我们该怎么做呢？我们以一个整型指针类型为例来看一下：

```go
var a int = 13
var p *int = &a  // 给整型指针变量p赋初值
```



在 Go 中声明一个变量。每当我们声明一个变量，Go 都会为变量分配对应的内存空间。

- **对于非指针类型变量，Go 在对应的内存单元中放置的就是该变量的值**
- **Go 为指针变量 p 分配的内存单元中存储的是整型变量 a 对应的内存单元的地址**。也正是由于指针类型变量存储的是内存单元的地址，指针类型变量的大小与其基类型大小无关，而是和系统地址的表示长度有关
  - 通过 unsafe.Sizeof 函数来计算每一个指针类型的大小，我们看到，无论指针的基类型是什么，不同类型的指针类型的大小在同一个平台上是一致的。在 x86-64 平台上，地址的长度都是 8 个字节。
  - **在 Go 语言中 uintptr 类型的大小就代表了指针类型的大小。**



**特殊指针类型：**

它不需要基类型，它就是 **unsafe.Pointer**。unsafe.Pointer 类似于 C 语言中的 void*，用于表示一个通用指针类型，也就是**任何指针类型都可以显式转换为一个 unsafe.Pointer，而 unsafe.Pointer 也可以显式转换为任意指针类型**

```go
var p *T
var p1 = unsafe.Pointer(p) // 任意指针类型显式转换为unsafe.Pointer
p = (*T)(p1)               // unsafe.Pointer也可以显式转换为任意指针类型
```

unsafe.Pointer 是 Go 语言的高级特性，在 Go 运行时与 Go 标准库中 unsafe.Pointer 都有着广泛的应用。但 unsafe.Pointer 属于 **unsafe 编程**范畴



## 二级指针

**二级指针就可以用来改变指针变量的值，也就是指针变量的指向。**



## **Go 中的指针用途与使用限制**

Go 是带有垃圾回收的编程语言，指针在 Go 中依旧位于 C 位，它的作用不仅体现在语法层面上，更体现在 Go 运行时层面，尤其是内存管理与垃圾回收这两个地方，这两个运行时机制**只关心指针**。

在语法层面，相对于“指针为王”的 C 语言来说，Go 指针的使用要少不少，这很大程度上是因为 Go 提供了更灵活和高级的复合类型，比如切片、map 等，并将使用指针的复杂性隐藏在运行时的实现层面了。

指针无论是在 Go 中，还是在其他支持指针的编程语言中，**存在的意义就是为了是“可改变”**。在 Go 中，我们使用 *T 类型的变量调用方法、以 *T 类型作为函数或方法的形式参数、返回 *T 类型的返回值等的目的，也都是因为指针可以改变其指向的内存单元的值。



> **限制一：限制了显式指针类型转换。**

```go
package main

import (
    "fmt"
    "unsafe"
)

func main() {
    var a int = 0x12345678
    var pa *int = &a
    var pb *byte = (*byte)(pa) // 编译器报错：cannot convert pa (variable of type *int) to type *byte
    fmt.Printf("%x\n", *pb)
}
```

正确做法：

```go
func main() {                                                                         
    var a int = 0x12345678                                                            
    var pa *int = &a                                                                  
    var pb *byte = (*byte)(unsafe.Pointer(pa)) // ok
    fmt.Printf("%x\n", *pb) // 78                                                          
} 
```



> **限制二：不支持指针运算**

为了安全性，Go 在语法层面抛弃了指针运算这个特性。如果我们非要做指针运算，Go 依然提供了 unsafe 的途径，比如下面通过 unsafe 遍历数组的代码：

```go
package main

import "unsafe"

func main() {
    var arr = [5]int{11, 12, 13, 14, 15}
    var p *int = &arr[0]
    var i uintptr
    for i = 0; i < uintptr(len(arr)); i++ {
        p1 := (*int)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i*unsafe.Sizeof(*p)))
        println(*p1)
    }           
}
```



## **make()和new()**

**new：**

**new函数得到的是一个类型的指针变量，并对应初始化零值**。因为指针作为引用类型需要初始化后才会拥有内存空间，才可以给他赋值，所以`var a *int`只是声明并没有初始化，可以用`a := new(int)`

**make:**

在Go中只用于slice、map以及channel的内存创建，并且他返回的类型就是这三个类型本身，而不是他们的指针类型。因为这三种类型就是引用类型，没必要返回他们的指针了。



# 流程控制

## if

> **if判断条件的优先级：**

![image-20221112185208277](markdown%E5%9B%BE%E7%89%87/image-20221112185208277.png)





> **创新点：支持声明 if 语句的自用变量**

无论是单分支、二分支还是多分支结构，我们都可以在 if 后的布尔表达式前，进行一些变 量的声明，在 if 布尔表达式前声明的变量，我叫它 if 语句的**自用变量**。顾名思义，这些变 量只可以在 if 语句的代码块范围内使用。这 些变量具有一定**隔离性**

```go
func main() {
    if a, c := f(), h(); a > 0 {
    println(a)
    } else if b := f(); b > 0 {
    println(a, b)
    } else {
    println(a, b, c)
    }
}
```



> **if的快乐路径原则**

**在日常编码中要减少多分支结构， 甚至是二分支结构的使用，这会有助于我们编写出优雅、简洁、易读易维护且不易错的代 码。**

- 仅使用单分支控制结构； 
- 当布尔表达式求值为 false 时，也就是出现错误时，在单分支中快速返回； 
- 正常逻辑在代码布局上始终“靠左”，这样读者可以从上到下一眼看到该函数正常逻辑 的全貌； 
- 函数执行到最后一行代表一种成功状态。



> **易错点**

**两个if语句如果是并列关系，这两个if快不能相互影响，否则要写成if elseif 形式**

```go
if count > max  {
    result = []int{node.Val}
    max = count
}
if count == max {
    result = append(result, node.Val)
}
```

上面的if里面的max设置会影响下面if的判断！！！



## for

### **两种不同形式的for**

> **第一种形式**：for

```go
for 1;2;3 {
    
}
```

Go 语言的 for 循环支持声明多循环变量，并 且可以应用在循环体以及判断条件中

```go
for i, j, k := 0, 1, 2; (i < 20) && (j < 10) && (k < 30); i, j, k = i+1, j+1,
    sum += (i + j + k)
    println(sum)
}

```

**可以对前置语句或后置语句进行了省略，但经典 for 循环 形式中的分号依然被保留着，你要注意这一点，这是 Go 语法的要求。**

当 for 循环语句的循环判断条件表达式的求值结果始终为 true 时，我们就可以将它 省略掉了

```go
for{
    
}
```



> **第二种形式：for range**

Go 语言提供了一个更方便的“语法 糖”形式：**for range**

```go
for i, v := range 复合类型对象 {

}
```

这里的 i 和 v 对应的是经典 for 语句形式中循环前置语句的循环变量，它们的 初值分别为**复合类型对象**的第一个元素的下标值和元素值。



对于i和v的关心程度，有三种变体。

```go
for i := range sl {
// ...
}
for _, v := range sl {
    // ...
}
for  range sl {
    // ...
}
```



这里的复合类型对象分为以下几种：

- 数组/切片：它们的 初值分别为切片 sl 的第一个元素的下标值和元素值。

- string：每次循环得到的 v 值是一个 Unicode 字符 码点，也就是 rune 类型值，而不是一个字节，返回的第一个值 i 为该 Unicode 字符码点 的内存编码（UTF-8）的第一个字节在字符串内存序列中的位置。

- **map:**对 map 进行循环操作，for range 是唯一的方法。每次循环，循环变量 k 和 v 分别 会被赋值为 map 键值对集合中一个元素的 key 值和 value 值

- **channel**：for range 每次从 channel 中读取一个元素后，会把它赋值给循环变量 v，并进入循环体。当 channel 中没有数据可读的时候，**for range 循环会阻塞**在对 channel 的读操作上。**直到 channel 关闭时，for range 循环才会结束**，这也是 **for range 循环与 channel 配合时隐含的循环判断条件**。

  ```go
  var c = make(chan int)
  for v := range c {
  // ...
  }
  ```

  

### **如何中断for语句**

> **第一种方法： （带label 的） continue 语句**

```go
   for i := 0; i < len(sl); i++ {
        for j := 0; j < len(sl[i]); j++ {
            if sl[i][j] == 13 {
                fmt.Printf("found 13 at [%d, %d]\n", i, j)
                continue outerloop
            }
        }
    }
outerloop:
    for i := 0; i < len(sl); i++ {
        for j := 0; j < len(sl[i]); j++ {
            if sl[i][j] == 13 {
                fmt.Printf("found 13 at [%d, %d]\n", i, j)
                continue outerloop
            }
        }
    }
```



> **第二种方法： （带label 的） break语句**



### **for 语句的常见“坑”与避坑方法**

for 语句的常见“坑”点通常和 for range 这个“语法糖”有关。

> **坑一：循环变量的重用**

```go
func main() {
    var m = []int{1, 2, 3, 4, 5}
    for i, v := range m {
        go func() {
        time.Sleep(time.Second * 3)
            fmt.Println(i, v)
        }
        time.Sleep(time.Second * 10)
    }
}
//实际输出
1 4 5
2 4 5
3 4 5
4 4 5
5 4 5
```

会被 for range 语句中 的短声明变量形式“迷惑”，简单地认为每次迭代都会重新声明两个新的变量 i 和 v。但事 实上，这些循环变量在 for range 语句中仅会被声明一次，且在每次迭代中都会被重用。

基于隐式代码块的规则， 我们可以将上面的 for range 语句做一个等价转换，这样可以帮助你理解 for range 的工 作原理。等价转换后的结果是这样的：

```go
func main() {
    var m = []int{1, 2, 3, 4, 5}
    {
        i, v := 0, 0
        for i, v = range m {
            go func() {
                time.Sleep(time.Second * 3)
                fmt.Println(i, v)
            }()
        }
    }
    time.Sleep(time.Second * 10)
}
```

通过等价转换后的代码，我们可以清晰地看到循环变量 i 和 v 在每次迭代时的重用。而 Goroutine 执行的**闭包函数引用了它的外层包裹函数中的变量 i、v**，这样，变量 i、v 在主 Goroutine 和新启动的 Goroutine 之间实现了共享，而 i, v 值在整个循环过程中是重用 的，仅有一份。在 for range 循环结束后，i = 4, v = 5，因此各个 Goroutine 在等待 3 秒 后进行输出的时候，输出的是 i, v 的最终值。



怎么改呢？可以为闭包函数 增加参数，并且在创建 Goroutine 时将参数与 i、v 的当时值进行绑定

```go
func main() {
    var m = []int{1, 2, 3, 4, 5}
    for i, v := range m {
        go func(i, v int) {
            time.Sleep(time.Second * 3)
            fmt.Println(i, v)
        }(i, v)
    }
    time.Sleep(time.Second * 10)
}

```



> **坑二：参与循环的是 range 表达式的副本**

```go
func main() {
    var a = [5]int{1, 2, 3, 4, 5}
    var r [5]int
    fmt.Println("original a =", a)
    for i, v := range a {
        if i == 0 {
            a[1] = 12
            a[2] = 13
        }
        r[i] = v
    }
    fmt.Println("after for range loop, r =", r)
    fmt.Println("after for range loop, a =", a)
}
//实际输出
riginal a = [1 2 3 4 5]
after for range loop, r = [1 2 3 4 5]
after for range loop, a = [1 12 13 4 5]
```

**原因就是参与 for range 循环的是 range 表达式的副本**。也就是 说，在上面这个例子中，真正参与循环的是 a 的副本，而不是真正的 a。

```go
for i, v := range a' { //a'是a的一个值拷贝
    if i == 0 {
        a[1] = 12
        a[2] = 13
    }
    r[i] = v
}
```

每次迭代的都是从数组 a 的值拷贝 a’中得到的元 素。a’是 Go 临时分配的连续字节序列，与 a 完全不是一块内存区域。因此无论 a 被如何 修改，它参与循环的副本 a’依旧保持原值，因此 v 从 a’中取出的仍旧是 a 的原值，而 不是修改后的值。



如何解决呢？在 Go 中，大多数应用数组的场景我们都可以**用切片替代（也可以用数组指针代替）**，这里我们也用切片来试试看。当进行 range 表达式复制时，我们实际上复制的是一个切片，也就是表示切片的结 构体。表示切片副本的结构体中的 array，依旧指向原切片对应的底层数组，所以我们对切 片副本的修改也都会反映到底层数组 a 上去。而 v 再从切片副本结构体中 array 指向的底 层数组中，获取数组元素，也就得到了被修改后的元素值。



> **坑三：遍历 map 中元素的随机性**

当 map 类型变量作为 range 表达式时，我们得到的 map 变量的副本与 原变量指向同一个 map。如果我们在循环的过程中，对 map 进行了修改，那么这样修改的结果是否会影响后续迭代呢？**这个结果和我们遍历 map 一样，具有随机性**

**考虑到上述这种随机性，我们日常编码遇到遍历 map 的同时，还需要对 map 进行修改的 场景的时候，要格外小心**



## switch

### **认识Go中的switch**

```go
switch initStmt; expr {
    case expr1:
    // 执行分支1
    case expr2:
    // 执行分支2
    case expr3_1, expr3_2, expr3_3:
    // 执行分支3
    case expr4:
    // 执行分支4
    ... ...
    case exprN:
    // 执行分支N
    default:
    // 执行默认分支
}
```

switch 关键字开始，它的后面通常接着一个**表达式（expr）**，这句中的 **initStmt 是一个可 选的组成部分**。和 if、for 语句一样，我们可以在 initStmt 中通过短变量声明定义一些在 switch 语句中使用的**临时变量**。

每个 case 后面是一个表达式或是一个逗号分隔的表达式列表。这里还有一个以 default 关 键字开始的特殊分支，被称为默认分支。

如果 switch 表达式匹配到了某个 case 表达式，那么程序就会执行这个 case 对应的代码 分支，比如示例中的“exec case2”。这个分支后面的 case 表达式将不会再得到求值机 会。**因此switch 语句是按照 case 出现 的先后顺序对 case 表达式进行求值的**，那么如果我们将匹配成功概率高的 case 表达式排 在前面，就会有助于提升 switch 语句执行效率。

**无论 default 分支出现在什么位置，它都只会 在所有 case 都没有匹配上的情况下才会被执行的。**



### **switch语句的灵活性**

**首先，switch 语句各表达式的求值结果可以为各种类型值，只要它的类型支持比较操作就 可以了。**

特殊的是：当 switch 表达式的类型为布尔类型时，如果求值结果始终为 true，那么我们甚至 可以省略 switch 后面的表达式

这里要注意，在带有 initStmt 的情况下，如果我们省略 switch 表达式，那么 initStmt 后面的分号不能省略，因为 initStmt 是一个语句。



**第二点：switch 语句支持声明临时变量。**

和 if、for 等控制结构语句一样， switch 语句的 initStmt 可用来声明只在这个 switch 隐式代码块中使用的变量，这种就近 声明的变量最大程度地缩小了变量的作用域。



**第三点：case 语句支持表达式列表**

```go
func checkWorkday(a int) {
    switch a {
        case 1, 2, 3, 4, 5:
        println("it is a work day")
        case 6, 7:
        println("it is a weekend day")
        default:
        println("are you live on earth")
    }
}
```



**第四点：取消了默认执行下一个 case 代码逻辑的语义。**

如果在少数场景下，你需要执行下一个 case 的代码逻辑，你可以显式使用 Go 提供的**关键 字 fallthrough** 来实现，这也是 Go“显式”设计哲学的一个体现

```go
func checkWorkday(a int) {
    switch a {
        case 1, 2, 3, 4, 5:
        	println("it is a work day")
        case 6, 7:
            println("it is a weekend day")
            fallthrough
        default:
        	println("are you live on earth")
    }
}
```



**第五点：type switch**

```go
func main() {
    var x interface{} = 13
    switch x.(type) {
        case nil:
        	println("x is nil")
        case int:
        	println("the type of x is int")
        case string:
        	println("the type of x is string")
        case bool:
        	println("the type of x is string")
        default:
        	println("don't support the type")
    }
}
```

switch 关键字后面跟着的表达式为**x.(type)**，**这种表达式形式是 switch 语句专有的**，而 且也只能在 switch 语句中使用。这个表达式中的 **x 必须是一个接口类型变量**，表达式的求 值结果是这个接口类型变量对应的**动态类型**。

不过，通过x.(type)，我们除了可以获得变量 x 的动态类型信息之外，也能获得其动态 类型对应的值信息，现在我们把上面的例子改造一下

```go
func main() {
    var x interface{} = 13
    switch v := x.(type) {
        case nil:
        	println("x is nil")
        case int:
        	println("the type of x is int")
        case string:
        	println("the type of x is string")
        case bool:
        	println("the type of x is string")
        default:
        	println("don't support the type")
    }
}
```

你千 万不要认为变量 v 存储的是类型信息，**其实 v 存储的是变量 x 的动态类型对应的值信息**， 这样我们在接下来的 case 执行路径中就可以使用变量 v 中的值信息了。



**第六点**：**`switch`语句在`case`子句的选择上是具有唯一性的**

`switch`语句在**`case`子句的选择上是具有唯一性的**。正因为如此，`switch`语句不允许`case`表达式中的子表达式结果值存在相等的情况，不论这些结果值相等的子表达式，是否存在于不同的`case`表达式中，都会是这样的结果。不过，好在这个约束本身还有个约束，那就是**只针对结果值为常量的子表达式**（把case表达式中的常量都换成了诸如value5[0]这样的索引表达式）

​		不过，这种绕过方式对用于类型判断的`switch`语句就无效了。因为类型`switch`语句中的`case`表达式的子表达式，都必须直接由类型字面量表示，而无法通过间接的方式表示。



### **坑点：跳不出循环的 break**

```go
func main() {
    var sl = []int{5, 19, 6, 3, 8, 12}
    var firstEven int = -1
    // find first even number of the interger slice
    for i := 0; i < len(sl); i++ {
        switch sl[i] % 2 {
            case 0:
            firstEven = sl[i]
            break
            case 1:
            // do nothing
        }
    }
    println(firstEven)
}

```

Go 语言规范中明确规定，不带 label 的 break 语句中断执行 并跳出的，是同一函数内 break 语句所在的最内层的 **for、switch 或 select。**



# 函数

## **Go函数与函数声明**

> **最常用的函数声明**：

```go
func Fprintf(w io.Writer, format string, a ...interface{})(n int, err error){
    //函数体
}
```

- **func**：Go 函数声明必须以关键字 func 开始。
- **函数名：**在同一个 Go 包中，函数名应该是唯一的，并且它也遵守 Go 标识符的导出规则，也就是我们之前说的，首字母大写的函数名指代的函数是可以在包外 使用的，小写的就只在包内可见。
- **参数列表**：Go 函数支持**变长参数**，也就是一个形式参数可以对应数量不定的实际参数。变长参数与普通参数在声明时的不同点，就在于它会在类型前面增加了一 个“…”符号。
- **返回值列表**：返回值列表声 明了这些返回值的类型。上述还声明 了返回值的名称，这种返回值被称为**具名返回值**。多数情况下，我们不需要这么做，只需 声明返回值的类型即可。
  - **只要声明函数的返回值变量名称，就会在函数初始化时候为之赋值为0，而且在函数体作用域可见**
- **函数体**：



> **等价的变量声明形式**：

```go
var Fprintf = func(w io.Writer, format string, a ...interface{})(n int, err error){
    //函数体
}
```

- 函数声明中的函数名其实就是**变量名**
- 函数声明中的 func 关键字、参数列表和 返回值列表共同构成了**函数类型**。
- 参数列表与返回值列表的组合也被称为**函数签名**，它 是决定两个函数类型是否相同的决定因素。因此，**函数类型也可以看成是由 func 关键字与 函数签名组合而成的。**
  - 通常，在表述函数类型时，我们会省略函数签名参数列表中的参数名，以及返回值列表中 的返回值变量名
  - 如果两个函数类型的函数签名是相同的，即便参数列表中的参数名，以及返回值列 表中的返回值变量名都是不同的，那么这两个函数类型也是相同类型



**结论：每个函数声明所定义的函数，仅仅是对应的函数类 型的一个实例**，就像var a int = 13这个变量声明语句中 a 是 int 类型的一个实例一 样。

**解释**：使用复合类型字面值对结构体类型变量进行显式初始化的内 容，你一定会觉得上面这种、用变量声明来声明函数变量的形式，似曾相识，我们把这两 种形式都以最简化的样子表现出来，看下面代码：

```go
s := T{} // 使用复合类型字面值对结构体类型T的变量进行显式初始化
f := func(){} // 使用变量声明形式的函数声明
```

这里，T{}被称为复合类型字面值，那么处于同样位置的 func(){}是什么呢？Go 语言也为它 准备了一个名字，叫**“函数字面值（Function Literal）**”。我们可以看到，**函数字面值由 函数类型与函数体组成**，它特别像一个**没有函数名的函数声明，因此我们也叫它匿名函 数**。



> **函数参数那些事儿**

Go 语言中，函数参数传递采用是**值传递**的方式。所谓“值传递”，就是将实际参数在内存 中的表示**逐位拷贝**到形式参数中

- 像整型、数组、结构体这类类 型，它们的内存表示就是它们自身的数据内容，因此当这些类型作为实参类型时，值传递 拷贝的就是它们自身，传递的开销也与它们自身的大小成正比。也称之为**深拷贝**
- 像 string、切片、map 这些类型就不是了，它们的内存表示对应的是它们数据内容 的“描述符”。当这些类型作为实参类型时，值传递拷贝的也是它们数据内容的“描述 符”，不包括数据内容本身，所以这些类型传递的开销是固定的，与数据内容大小无关。 这种只拷贝“描述符”，不拷贝实际数据内容的拷贝过程，也被称为“**浅拷贝**”。

**例外**：当函数的形参为接口类型，或者形参是变长参数时， 简单的值传递就不能满足要求了，这时 **Go 编译器会介入**：

- 对于类型为接口类型的形参， Go 编译器会把传递的实参赋值给对应的接口类型形参；
- 对于为变长参数的形参，Go 编译 器会将零个或多个实参按一定形式转换为对应的变长形参。**在 Go 中，变长参数实际上是通过切片来实现的。**



> **函数支持多返回值：**

**多返回值 可以让函数将更多结果信息返回给它的调用者，Go 语言的错误处理机制很大程度就是建立 在多返回值的机制之上的**

**一般场景：Go 标准库以及大多数项目代码中的函数，都选择了使用普通的非具名返回值形式**

```go
func foo() // 无返回值
func foo() error // 仅有一个返回值
func foo() (int, string, error) // 有2或2个以上返回值
```



> **具名返回值**：

比如：

- 当函数使用 defer，而且还在 defer 函 数中修改外部函数返回值时，具名返回值可以让代码显得更优雅清晰。
- 当函数的返回值个数较多时，每次显式使用 return 语句时都会接一长串返回值， 这时，我们用具名返回值可以让函数实现的可读性更好一些

```go
func foo() (err error) // 仅有一个返回值
func foo() (a int,b string,c error) // 有2或2个以上返回值
```



## **函数是“一等公民”**

如果一门编程语言对某种语言元素的创建和使用没有限制，我们可以像对待值（value） 一样对待这种语法元素，那么我们就称这种语法元素是这门编程语言的“**一等公民**”。 拥有“一等公民”待遇的语法元素可以存储在变量中，可以作为参数传递给函数，可以 在函数内部创建并可以作为返回值从函数返回。

> **特征一：Go函数可以存储在变量中**

```go
var (
    myFprintf = func(w io.Writer, format string, a ...interface{}) (int, error){
		return fmt.Fprintf(w, format, a...)
	}
)
func main() {
	fmt.Printf("%T\n", myFprintf) // func(io.Writer, string, ...interface {})
	myFprintf(os.Stdout, "%s\n", "Hello, Go") // 输出Hello，Go
}

```



> **特征二：支持在函数内创建并通过返回值返回。**

```go
func setup(task string) func() {
	println("do some setup stuff for", task)
	return func() {
		println("do some teardown stuff for", task)
	}
}
func main() {
	teardown := setup("demo")
	defer teardown()
	println("do some bussiness stuff")
}
```

这个例子，模拟了执行一些重要逻辑之前的上下文建立（setup），以及之后的上下文拆除 （teardown）。在一些单元测试的代码中，我们也经常会在执行某些用例之前，建立此次 执行的上下文（setup），并在这些用例执行后拆除上下文（teardown），避免这次执行 对后续用例执行的干扰。

setup 函数中创建的拆除函数也是一个匿名函数，但和前 面我们看到的匿名函数有一个不同，这个不同就在于这个匿名函数使用了定义它的函数 setup 的局部变量 task，这样的**匿名函数**在 Go 中也被称为**闭包**

**闭包本质上就是一个匿名函数或叫函数字面值**，它们可以引用它的包裹函数，也就是创建 它们的函数中定义的变量。然后，这些变量在包裹函数和匿名函数之间共享，只要闭包可以被访问，这些共享的变量就会继续存在。显然，**Go 语言的闭包特性也是建立在“函数是 一等公民”特性的基础上的**

**不恰当比方：**

- 可以把闭包看成一个类，**一个闭包函数就是实例化一个类。运行时可以有多个实例**，将同一个作用域的变量和常量捕获下来，且是引用传递。
- **闭包函数：=主函数（参数）{相当于初始化一个类}；**主函数（参数）（）这里每次结果都一样，主函数被调用结束就被释放了。
- **闭包函数（），闭包函数（）{相当于实例化两个对象，都是引用传递}**；



> **特征三：作为参数传入函数**。

```go
 time.AfterFunc(time.Second*2, func() { println("timer fired") })
```



> **特征四：拥有自己的类型。**

```go
// $GOROOT/src/net/http/server.go
type HandlerFunc func(ResponseWriter, *Request)
// $GOROOT/src/sort/genzfunc.go
type visitFunc func(ast.Node) ast.Visitor
```



## **函数“一等公民”特性的高效运用**

> **应用一：函数类型的妙用**

**函数也 可以被显式转型**。并且，这样的转型在特定的领域具有奇妙的作用，一个最为典型的示例 就是标准库 http 包中的 HandlerFunc 这个类型

```go
func greeting(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, "Welcome, Gopher!\n")
}
func main() {
	http.ListenAndServe(":8080", http.HandlerFunc(greeting))
}
```

先来看一下 http 包的函数 ListenAndServe 的源码

```go
// $GOROOT/src/net/http/server.go
func ListenAndServe(addr string, handler Handler) error {
    server := &Server{Addr: addr, Handler: handler}
    return server.ListenAndServe()
}
```

函数 ListenAndServe 会把来自客户端的 http 请求，交给它的第二个参数 handler 处理， 而这里 handler 参数的类型 http.Handler，是一个自定义的接口类型

```go
// $GOROOT/src/net/http/server.go
type Handler interface {
	ServeHTTP(ResponseWriter, *Request)
}
```

这个接口 只有一个方法 ServeHTTP，他的函数类型是func(http.ResponseWriter, *http.Request)。这和我们自己定义的 http 请求处理函数 greeting 的类型是一致的， 但是我们没法直接将 greeting 作为参数值传入，否则编译器会报错,编译器提示我们，函数 greeting 还没有实现接口 Handler 的方法，无法将它赋值 给 Handler 类型的参数。

代码中将http.HandlerFunc(greeting)作为参 数传给了 ListenAndServe。那这个 http.HandlerFunc 究竟是什么呢？

```go
// $GOROOT/src/net/http/server.go
type HandlerFunc func(ResponseWriter, *Request)
// ServeHTTP calls f(w, r).
func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {
	f(w, r)
}
```

**HandlerFunc 是一个基于函数类型定义的新类型，它的底层类型 为函数类型func(ResponseWriter, *Request)。**这个类型有一个方法 ServeHTTP， 然后实现了 Handler 接口。也就是说http.HandlerFunc(greeting)这句代码的真正 含义，是将函数 greeting 显式转换为 HandlerFunc 类型，后者实现了 Handler 接口，满 足 ListenAndServe 函数第二个参数的要求。

另外，之所以http.HandlerFunc(greeting)这段代码可以通过编译器检查，正是因为 **HandlerFunc 的底层类型是func(ResponseWriter, *Request)，与 greeting 函数 的类型是一致的**，这和下面整型变量的**显式转型**原理也是一样的



> **应用二：利用闭包简化函数调用。**

**Go 闭包是在函数内部创建的匿名函数，这个匿名函数可以访问创建它的函 数的参数与局部变量。**

```go
func times(x, y int) int {
	return x * y
}
```

有些场景存在一些高频使用的乘数，这个时候我们就没必要每次都传入这样的高频 乘数了。那我们怎样能省去高频乘数的传入呢? 我们看看下面这个新函数 partialTimes：

```go
func partialTimes(x int) func(int) int {
	return func(y int) int {
		return times(x, y)
	}
}
```



## **Go 语言是如何进行错误处理的？**

首先，Go 语言错误处理机制也是在 C 语言错误处理机制基础上的再创新。

在 C 语言中，我们 通常用一个类型为整型的函数返回值作为错误状态标识，函数调用者会基于值比较的方 式，对这一代表错误状态的返回值进行检视。

**优点**：过显式错误处理的代码会 更健壮，这些错误就是普通的值，所以我们不需要用额外的语言机制去处理 它们

**弊端**：C 语言中的函数最多仅支持一个返回值，很多开发者会把这单一的返回值“一值多用”



Go 函数增加了**多返回值机制**，来支持错误状态与返回信息的分离，并 建议开发者把要返回给调用者的信息和错误状态标识，分别放在不同的返回值中。

**Go 语言惯用法**，是使用 error 这个接口类型表示错误，并且按惯例，我们通常将 error 类型返回值放在返回值列表的末尾，就像 fmt.Fprintf 函数声明中那样。



> **error类型与错误值构造**

error 接口是 Go 原生内置的类型，任何实现了 error 的 Error 方法的类型的实例，都可以作为错误值赋值给 error 接口变量。

```go
// $GOROOT/src/builtin/builtin.go
type interface error {
	Error() string
}
```

问题就来了：**难道为了构造一个错误值，我们还需要自定义一个新类型来实现 error 接口吗？**

Go 语言的设计者显然也想到了这一点，他们在标准库中提供了两种方便 Go 开发者构造错 误值的方法： **errors.New和fmt.Errorf**

```go
err := errors.New("your first demo error")
errWithCtx = fmt.Errorf("index %d is out of bounds", i)
```

这两种方法实际上返回的是同一个实现了 error 接口的类型的实例，这个未导出的类型就 是errors.errorString

```go
// $GOROOT/src/errors/errors.go
type errorString struct {
	s string
}
func (e *errorString) Error() string {
	return e.s
}
```

大多数情况下，使用这两种方法构建的错误值就可以满足我们的需求了。但我们也要看 到，虽然这两种构建错误值的方法很方便，但它们给错误处理者提供的错误上下文（Error Context）只限于以字符串形式呈现的信息，也就是 Error 方法返回的信息。

但在一些场景下，错误处理者需要从错误值中提取出更多信息，帮助他选择错误处理路 径，显然这两种方法就不能满足了。这个时候，我们可以**自定义错误类型**来满足这一需 求。比如：标准库中的 net 包就定义了一种携带额外错误上下文的错误类型：

```go
// $GOROOT/src/net/net.go
type OpError struct {
    Op string
    Net string
    Source Addr
    Addr Addr
    Err error
}
// $GOROOT/src/net/http/server.go
func isCommonNetReadError(err error) bool {
    if err == io.EOF {
    	return true
    }
    if neterr, ok := err.(net.Error); ok && neterr.Timeout() {
    	return true
    }
    if oe, ok := err.(*net.OpError); ok && oe.Op == "read" {
   		 return true
    }
    return false
}
```

上面这段代码利用类型断言，判断 error 类型变量 err 的动态类型是否为 *net.OpError 或 net.Error。如果 err 的动态类型是 *net.OpError，那么类型断言就会返回这个动态类型的值（存储在 oe 中），代码就可以通过判断它的 Op 字段是否 为"read"来判断它是否为 CommonNetRead 类型的错误。



因此，使用 error 类型，而不是传统意义上的整型或其他类型作为错误类型，有什么好处 呢？至少有这三点好处

- **第一点：统一了错误类型**。

- **第二点：错误是值。**

- **第三点：易扩展，支持自定义错误上下文。**



## **Go语言几种错误处理惯用策略**

> **策略一：透明错误处理策略**

最简单的错误策略莫过于完全不关心返回错误值携带的具体上下文信息，只要发生 错误就进入唯一的错误处理执行路径

```go
err := doSomething()
if err != nil {
    // 不关心err变量底层错误值所携带的具体上下文信息
    // 执行简单错误处理逻辑并返回
    ... ...
    return err
}
```

在这种策略下，由于错误处理方并不关心错误值的上下文，所以错误值的构造 方（如上面的函数doSomething）可以直接使用 Go 标准库提供的两个基本错误值构造方 法errors.New和fmt.Errorf来构造错误值，就像下面这样：

```go
func doSomething(...) error {
    ... ...
    return errors.New("some error occurred")
}
```



> **策略二：“哨兵”错误处理策略**

当错误处理方不能只根据“透明的错误值”就做出错误处理路径选取的情况下，错误处理 方会尝试对返回的错误值进行检视，于是就有可能出现下面代码中的**反模式**

```go
data, err := b.Peek(1)
if err != nil {
    switch err.Error() {
        case "bufio: negative count":
        // ... ...
        return
    }
}
```

反模式就是，错误处理方以透明错误值所能提供的**唯一上下文信息（描述错误 的字符串）**，作为错误处理路径选择的依据。但这种“反模式”会造成严重的**隐式耦合。** 这也就意味着，错误值构造方不经意间的一次错误描述字符串的改动，都会造成**错误处理 方处理行为的变化(case的不匹配)**，并且这种通过字符串比较的方式，对错误值进行检视的性能也很差。



于是，Go 标准库采用了**定义导出的（Exported）“哨兵”错误值的方式**， 来辅助错误处理方检视（inspect）错误值并做出错误处理分支的决策

```go
// $GOROOT/src/bufio/bufio.go
var (
    ErrInvalidUnreadByte = errors.New("bufio: invalid use of UnreadByte")
    ErrInvalidUnreadRune = errors.New("bufio: invalid use of UnreadRune")
    ErrBufferFull = errors.New("bufio: buffer full")
    ErrNegativeCount = errors.New("bufio: negative count")
)

data, err := b.Peek(1)
if err != nil {
    switch err {
    case bufio.ErrNegativeCount:
    // ... ...
    return
    case bufio.ErrBufferFull:
    // ... ...
    return
    case bufio.ErrInvalidUnreadByte:
    // ... ...
    return
    default:
    // ... ...
    return
    }
}

```

一般“哨兵”错误值变量以 ErrXXX 格式命名。和透明错误策略相比，“哨 兵”策略让错误处理方在有检视错误值的需求时候，可以“有的放矢”。

但**缺点**是：对于 API 的开发者而言，暴露“哨兵”错误值也意味着这些错误值和包的公共函数 / 方法一起成为了 API 的一部分。一旦发布出去，开发者就要对它进行很好的维护。 而“哨兵”错误值也让使用这些值的错误处理方对它产生了依赖。



从 Go 1.13 版本开始，标准库 **errors 包提供了 Is 函数用于错误处理方对错误值的检视**。Is 函数类似于把一个 error 类型变量与“哨兵”错误值进行比较

```go
// 类似 if err == ErrOutOfBounds{ … }
if errors.Is(err, ErrOutOfBounds) {
	// 越界的错误处理
}
```

不同的是，如果 error 类型变量的底层错误值是一个包装错误（Wrapped Error）， errors.Is 方法会沿着该包装错误所在错误链（Error Chain)，与链上所有被包装的错误 （Wrapped Error）进行比较，直至找到一个匹配的错误为止。比如：

```go
var ErrSentinel = errors.New("the underlying sentinel error")
func main() {
    err1 := fmt.Errorf("wrap sentinel: %w", ErrSentinel)
    err2 := fmt.Errorf("wrap err1: %w", err1)
    println(err2 == ErrSentinel) //false
    if errors.Is(err2, ErrSentinel) {
    println("err2 is ErrSentinel")
    return
    }
    println("err2 is not ErrSentinel")
}
//false
//err2 is ErrSentinel
```

在上例中，我们通过 fmt.Errorf 函数，并且使用 %w 创建包装错误变量 err1 和 err2，其中 err1 实现了对 ErrSentinel 这个“哨兵错误值”的包装，而 err2 又对 err1 进 行了包装，这样就形成了一条错误链。位于错误链最上层的是 err2，位于最底层的是 ErrSentinel。



> **策略三：错误值类型检视策略**

基于 Go 标准库提供的错误值构造方法构造的“哨兵”错误值，除了让错 误处理方可以“有的放矢”的进行值比较之外，并**没有提供其他有效的错误上下文信息。**

如果遇到错误处理方需要错误值提供更多的“错误上下文”的情况，上面这些错误处理 策略和错误值构造方式都无法满足。我们需要通过自定义错误类型的构造错误值的方式，来提供更多的“错误上 下文”信息。并且，由于错误值都通过 error 接口变量统一呈现，要得到底层错误类型携带的错误上下文信息，错误处理方需要使用 Go 提供的类型**断言机制（Type Assertion） 或类型选择机制（Type Switch）**，这种错误处理方式，我称之为**错误值类型检视策略。**

来看一个标准库中的例子加深下理解，这个 json 包中自定义了一个 UnmarshalTypeError的错误类型：

```go
// $GOROOT/src/encoding/json/decode.go
type UnmarshalTypeError struct {
    Value string
    Type reflect.Type
    Offset int64
    Struct string
    Field string
}
```

```go
// $GOROOT/src/encoding/json/decode.go
func (d *decodeState) addErrorContext(err error) error {
    if d.errorContext.Struct != nil || len(d.errorContext.FieldStack) > 0 {
        switch err := err.(type) {
        case *UnmarshalTypeError:
            err.Struct = d.errorContext.Struct.Name()
            err.Field = strings.Join(d.errorContext.FieldStack, ".")
            return err
        }
    }
    return err
}
```

这段代码通过类型 switch 语句得到了 err 变量代表的动态类型和值，然后在匹 配的 case 分支中利用错误上下文信息进行处理。 这里，**一般自定义导出的错误类型以XXXError的形式命名**.

和“哨兵”错误处理策略一 样，错误值类型检视策略，由于暴露了自定义的错误类型给错误处理方，因此这些错误类型也和包的公共函数 / 方法一起，成为了 API 的一部分。一旦发布出去，开发者就要对它 们进行很好的维护。而它们也让使用这些类型进行检视的错误处理方对其产生了依赖。



从 Go 1.13 版本开始，**标准库 errors 包提供了As函数给错误处理方检视错误值**。As函数 类似于通过类型断言判断一个 error 类型变量是否为特定的自定义错误类型

```go
// 类似 if e, ok := err.(*MyError); ok { … }
var e *MyError
if errors.As(err, &e) {
	// 如果err类型为*MyError，变量e将被设置为对应的错误值
}
```

不同的是，如果 error 类型变量的动态错误值是一个包装错误，errors.As函数会沿着该 包装错误所在错误链，与链上所有被包装的错误的类型进行比较，直至找到一个匹配的错 误类型，就像 errors.Is 函数那样

```go
type MyError struct {
	e string
}
func (e *MyError) Error() string {
	return e.e
}
func main() {
    var err = &MyError{"MyError error demo"}
    err1 := fmt.Errorf("wrap err: %w", err)
    err2 := fmt.Errorf("wrap err1: %w", err1)
    var e *MyError
    if errors.As(err2, &e) {
    println("MyError is on the chain of err2")
    println(e == err)
    return
    }
    println("MyError is not on the chain of err2")
}
//MyError is on the chain of err2
//true
```



> **策略四：错误行为特征检视策略**

在前面我们已经讲过的三种策略中，其实只有第一种策略，也就 是“透明错误处理策略”，有效降低了错误的构造方与错误处理方两者之间的耦合。虽然 前面的策略二和策略三，都是我们实际编码中有效的错误处理策略，但其实使用这两种策 略的代码，依然在错误的构造方与错误处理方两者之间建立了耦合。

在 Go 标准库中，我们发现了这样一种错误处理方式：**将某个包中的错误类型归类，统一 提取出一些公共的错误行为特征，并将这些错误行为特征放入一个公开的接口类型中。这 种方式也被叫做错误行为特征检视策略。**



以标准库中的net包为例，它将包内的所有错误类型的公共行为特征抽象并放入 net.Error这个接口中

```go
// $GOROOT/src/net/net.go
type Error interface {
    error
    Timeout() bool
    Temporary() bool
}
```

net.Error 接口包含两个用于判断错误行为特征的方法：Timeout 用来判断是否 是超时（Timeout）错误，Temporary 用于判断是否是临时（Temporary）错误。 而错误处理方只需要依赖这个公共接口，就可以检视具体错误值的错误行为特征信息，并 根据这些信息做出后续错误处理分支选择的决策。



再看一个 http 包使用错误行为特征检视策略进行错误处理的例子，加深下理 解：

```go
// $GOROOT/src/net/http/server.go
func (srv *Server) Serve(l net.Listener) error {
    ... ...
    for {
        rw, e := l.Accept()
        if e != nil {
            select {
            case <-srv.getDoneChan():
            return ErrServerClosed
            default:
            }
            if ne, ok := e.(net.Error); ok && ne.Temporary() {
                // 注：这里对临时性(temporary)错误进行处理
                ... ...
                time.Sleep(tempDelay)
                continue
                }
                return e
        }
        ...
    }
    ... ...
}
```

Accept 方法实际上返回的错误类型为*OpError，它是 net 包中的一个自 定义错误类型，它实现了错误公共特征接口net.Error，因此，OpError 实例可以被错误处理方通过net.Error接口的方法，判断它的行为是否满 足 Temporary 或 Timeout 特征。

```go
// $GOROOT/src/net/net.go
type OpError struct {
    ... ...
    // Err is the error that occurred during the operation.
    Err error
}
type temporary interface {
	Temporary() bool
}
func (e *OpError) Temporary() bool {
    if ne, ok := e.Err.(*os.SyscallError); ok {
    t, ok := ne.Err.(temporary)
    return ok && t.Temporary()
    }
    t, ok := e.Err.(temporary)
    return ok && t.Temporary()
}
```



**使用建议**

- 请尽量使用“透明错误”处理策略，降低错误处理方与错误值构造方之间的耦合；
- 如果可以通过错误值类型的特征进行错误检视，那么请尽量使用“错误行为特征检视策 略”；
- 在上述两种策略无法实施的情况下，再使用“哨兵”策略和“错误值类型检视”策略； Go 1.13 及后续版本中，尽量用errors.Is和errors.As函数替换原先的错误检视比 较语句。



## **Go语言函数设计的健壮性**

> **健壮性三不要原则**

- **原则一：不要相信任何外部输入的参数。**

  为了保证函数的健壮性，函数需要对所有输 入的参数进行合法性的检查。一旦发现问题，立即终止函数的执行，返回预设的错误值。

- **原则二：不要忽略任何一个错误。**

  在我们的函数实现中，也会**调用标准库或第三方包提供的函数或方法**。对于这些调用，我 们不能假定它一定会成功，我们一定要显式地检查这些调用返回的错误值。一旦发现错 误，要及时终止函数执行，防止错误继续传播

- **原则三：不要假定异常不会发生。**

  异常不是错误。错误是可预期的，也是经常会发生的，我 们有对应的公开错误码和错误处理预案，但异常却是少见的、意料之外的。

  通常意义上的 异常，指的是硬件异常、操作系统异常、语言运行时异常，还有更大可能是代码中潜在 bug 导致的异常，比如代码中出现了以 0 作为分母，或者是数组越界访问等情况。



> **Go语言异常处理设计：panic**

panic 指的是 Go 程序在运行时出现的一个异常情况。如果异常出现了，但没有被捕获并 恢复，Go 程序的执行就会被终止，即便出现异常的位置不在主 Goroutine 中也会这样。

在 Go 中，panic 主要有两类来源，一类是来自 **Go 运行时**，另一类则是 Go 开发人员**通 过 panic 函数主动触发的**。无论是哪种，一旦 panic 被触发，后续 Go 程序的执行过程都 是一样的，这个过程被 Go 语言称为 **panicking**。

**panicking**： 当函数 F 调用 panic 函数时，函数 F 的执行将停止。不过，函数 F 中已进行求值的 deferred 函数都会得到正常执行，执行完这些 deferred 函数后，函数 F 才会把控制权返 还给其调用者。对于函数 F 的调用者而言，函数 F 之后的行为就如同调用者调用的函数是 panic 一样，该 panicking过程将继续在栈上进行下去，直到当前 Goroutine 中的所有函数都返回为 止，然后 Go 程序将崩溃退出。

```go
func foo() {
    println("call foo")
    bar()
    println("exit foo")
}
func bar() {
    println("call bar")
    panic("panic occurs in bar")
    zoo()
    println("exit bar")
}
func zoo() {
    println("call zoo")
    println("exit zoo")
}
func main() {
    println("call main")
    foo()
    println("exit main")
}
//call main
//call foo
//call bar
//panic: panic occurs in bar
```

Go 也提供了捕捉 panic 并恢复程序正常执行秩序的方法，我们可以通过 **recover** 函数来实现这一点。

```go
func foo() {
    println("call foo")
    bar()
    println("exit foo")
}
func bar() {
    defer func() {
        if e := recover(); e != nil {
        fmt.Println("recover the panic:", e)
        }
        }()
    println("call bar")
    panic("panic occurs in bar")
    zoo()
    println("exit bar")
}
func zoo() {
    println("call zoo")
    println("exit zoo")
}
func main() {
    println("call main")
    foo()
    println("exit main")
}
//call main
//call foo
//call bar
//recover the panic: panic occurs in bar
//exit foo
//exit main
```

recover 是 Go 内置的**专门用于恢复 panic 的函数**，它**必须被放在一个 defer 函数 中才能生效**。如果 recover 捕捉到 panic，它就会返回以 panic 的具体内容为错误上下文 信息的错误值。如果没有 panic 发生，那么 recover 将返回 nil。而且，如果 panic 被 recover 捕捉到，panic 引发的 panicking 过程就会停止。



> **如何应对panic**

是不是在所有 Go 函数或方法中， 我们都要用 defer 函数来捕捉和恢复 panic 呢？

其实大可不必。 

- 这样做会徒增开发人员函数实现时的心智负担。
- 很多函数非常简单，根本不会出现 panic 情况，我们增加 panic 捕获和恢复，反倒会增加函数的复杂性。
- 同时， defer 函数也不是“免费”的，也有带来性能开销

**第一点：评估程序对 panic 的忍受度**

**第二点：提示潜在 bug**

**第三点：不要混淆异常与错误**



## **Go语言函数设计的简洁性**

> **使用 defer 简化函数实现**

**defer** 是 Go 语言提供的一种**延迟调用**机制，defer 的运作离不开函数。

- 在 Go 中，只有在函数（和方法）内部才能使用 defer； 
- defer 关键字后面只能接函数（或方法），这些函数被称为 **deferred 函数**。defer 将它 们注册到其所在 Goroutine 中，用于存放 deferred 函数的栈数据结构中，这些 deferred 函数将在执行 defer 的函数退出前，按后进先出（LIFO）的顺序被程序调度执 行
- 无论是执行到函数体尾部返回，还是在某个错误处理分支显式 return，又或是出现 panic，已经存储到 deferred 函数栈中的函数，都会被调度执行。所以说，deferred 函数 是一个可以在任何情况下为函数进行**收尾工作**的好“伙伴”。



> **defer使用的几个注意事项**

**第一点：明确哪些函数可以作为 deferred 函数**

 Go 语言内置的 / 预定义的函数，这里我给 出了 Go 语言内置函数的完全列表：

```go
append cap close complex copy delete imag len
make new panic print println real recover
```

- 对于自定义的函数或方法，defer 可以给与无条件的支持，但是**对于有返 回值的自定义函数或方法，返回值会在 deferred 函数被调度执行的时候被自动丢弃(间接说明了defered函数：在函数参数引用返回闭包的情况下，闭包函数才是真正的defered函数)**。

-  close、copy、delete、print、recover 等内置 函数则可以直接被 defer 设置为 deferred 函数

- append、cap、len、make、new、imag 等内置函数 都是不能直接作为 deferred 函数的。**对于那些不能直接作为 deferred 函数的内置函数，我们可以使用一个包裹它的匿名 函数来间接满足要求**，以 append 为例是这样的

  ```go
  defer func() {
  _ = append(sl, 11)
  }()
  ```



**第二点：注意 defer 关键字后面表达式的求值时机**

**牢记一点**：**defer 关键字后面的表达式，是在将 deferred 函数注册到 deferred 函数栈的时候进行求值的。**

```go
func foo1() {
	for i := 0; i <= 3; i++ {
		defer fmt.Println(i)
	}
}
func foo2() {
	for i := 0; i <= 3; i++ {
		defer func(n int) {
			fmt.Println(n)
		}(i)
	}
}
func foo3() {
    for i := 0; i <= 3; i++ {
		defer func() {
			fmt.Println(i)
		}()
	}
}
func main() {
    fmt.Println("foo1 result:")
    foo1()
    fmt.Println("\nfoo2 result:")
    foo2()
    fmt.Println("\nfoo3 result:")
    foo3()
}
```

foo1 中 defer 后面直接用的是 fmt.Println 函数，每当 defer 将 fmt.Println 注册到 deferred 函数栈的时候，都会对 Println 后面的参数进行求值。根据上 述代码逻辑，依次压入 deferred 函数栈的函数是：

```go
fmt.Println(0)
fmt.Println(1)
fmt.Println(2)
fmt.Println(3)
```

foo2 中 defer 后面接的是一个带有一个参数的匿名函数。每当 defer 将匿名函数注册到 deferred 函数栈的时候，都会对该匿名函数的参数进行求值。根 据上述代码逻辑，依次压入 deferred 函数栈的函数是：

```go
func(0)
func(1)
func(2)
func(3)
```

foo3 中 defer 后面接的是一个不带参数的匿名函数。根据上述代码 逻辑，依次压入 deferred 函数栈的函数是：

```go
func()
func()
func()
func()
```



**第三点：知晓 defer 带来的性能损耗**

使用 defer 的函数的执行时间是没有使用 defer 函数的 8 倍左右。

 但从 Go 1.13 版本开始，Go 核心团队对 defer 性能进行了多次优化，到现在的 Go 1.17 版本，defer 的开销已经足够小了,带有 defer 的函数执行开销，仅是不带有 defer 的函数的执行开销的 1.45 倍左 右，已经达到了几乎可以忽略不计的程度，我们可以放心使用。



# 方法

**一阵见血**：**函数承载了 Go 程序的所有执行逻辑。可以说，Go 程序的执行流本 质上就是在函数调用栈中上下流动，从一个函数到另一个函数。**

## **认识Go方法**

Go 语言从设计伊始，就不支持经典的面向对象语法元素，比如类、对象、继 承，等等，但 Go 语言仍保留了名为“方法（method）”的语法元素。当然，Go 语言中 的方法和面向对象中的方法并不是一样的。**Go 引入方法这一元素，并不是要支持面向对象 编程范式，而是 Go 践行组合设计哲学的一种实现层面的需要。**

比如Go标准库 net/http 包中 *Server 类型的方法 ListenAndServeTLS，**Go方法的一般形式：**

![image-20221115094000523](markdown%E5%9B%BE%E7%89%87/image-20221115094000523.png)

Go 方法的声明有**六个组成部分**，多的一个就是图中的 receiver 部分。在 receiver 部分声明的参数，Go 称之为 receiver 参数，**这个 receiver 参数也是方法与类型之间的纽 带，也是方法与函数的最大不同。**



## **receiver参数**

**Go 中的方法必须是归属于一个类型**的，而 receiver 参数的类型就是这个方法归属的类 型，或者说这个方法就是这个类型的一个方法。

比如：ListenAndServeTLS 是 *Server 类型的方法，而不是 Server 类型的 方法。



其实一个方法的一般声明形式可视为如下：

![image-20221115094252450](markdown%E5%9B%BE%E7%89%87/image-20221115094252450.png)

无论 receiver 参数的类型为 *T 还是 T，我们都把一般声明形式中的 T 叫做 receiver 参数 t 的**基类型**。如果 t 的类型为 T，那么说这个方法是类型 T 的一个方法；如果 t 的类型为 *T，那么就说这个方法是类型 *T 的一个方法。要**注意的是**，每个方法只能有一个 receiver 参数，Go 不支持在方法的 receiver 部分放置包含多个 receiver 参数的参数列 表，或者变长 receiver 参数。

Go 语言对 receiver 参数的基类型也有约束，那就 是 **receiver 参数的基类型本身不能为指针类型或接口类型。**



receiver参数作用域：**方法接收器（receiver）参数、函数 / 方法参数，以及返回值变量对应的作用域 范围，都是函数 / 方法体对应的显式代码块。**

- 这就意味着，receiver 部分的参数名不能与方法参数列表中的形参名，以及具名返回值中 的变量名存在冲突，必须在这个方法的作用域中具有唯一性。如果这个不唯一不存在，比 如像下面例子中那样，Go 编译器就会报错
- 不过，如果在方法体中，我们没有用到 receiver 参数，我们也可以省略 receiver 的参数 名



**Go 对方法声明的位置也是有约束的，Go 要求，方法声明要与 receiver 参数的基 类型声明放在同一个包内。**

- **第一个推论：我们不能为原生类型（诸如 int、float64、map 等）添加方法。**
- 第二个推论：**不能跨越 Go 包为其他包的类型声明新方法。**



## **方法的本质是什么？**

方法的类型是什么？我们是 否可以将方法赋值给函数类型的变量？调用方法时方法对 receiver 参数的修改是不是外部 可见的？

Go 的方法与 Go 中的类型是通过 receiver 联系在一起，可以为任何非内置原生类型定义方法，比如下面的类型 T

```go
type T struct {
	a int
}
func (t T) Get() int {
	return t.a
}
func (t *T) Set(a int) int {
	t.a = a
	return t.a
}
```

**C++ 中的对象在调用方法时，编译器会自动传入指向对象自身的 this 指针作为方法的第一个参数。**Go 方法中的原理也是相似的，只不过我们是**将 receiver 参数以第一个参数的身份并入 到方法的参数列表中。**

因此，示例中的类型 T 和 *T 的方法，就可以分别等价 转换为下面的普通函数：

```go
// 类型T的方法Get的等价函数
func Get(t T) int {
	return t.a
}
// 类型*T的方法Set的等价函数
func Set(t *T, a int) int {
	t.a = a
	return t.a
}

```

这种等价转换后的函数的类型就是**方法的类型。**在 Go 语言中，这种等价转换是由 **Go 编译器在编译和生成代码时自动完成**的。Go 语言规范中还提供了**方法表达式（Method Expression）**的概念，可以让我们更充分地理解上面的等价转换。

结合上面俩种定义方式，我们可以得到俩种调用方式，就是一个方法调用的等价替换。

```go
//1
var t T
t.Get()
t.Set(1)

//2
var t T
T.Get(t)
(*T).Set(&t, 1)
```

第二种直接以**类型名 T 调用方法的表达方式**，被称为 **Method Expression**。**通过 Method Expression 这种形式，类型 T 只能调用 T 的方法集合（Method Set）中的方法，同理类 型 *T 也只能调用 *T 的方法集合中的方法。**



所以，**Go 语言中的方法的本质就是，一个以方法的 receiver 参数 作为第一个参数的普通函数**。Method Expression 就是 Go 方法本质的最好体现，因为方法自身的类型就是一个 普通函数的类型，我们甚至可以将它作为右值，赋值给一个函数类型的变量

```go
func main() {
    var t T
    f1 := (*T).Set // f1的类型，也是T类型Set方法的类型：func (t *T, int)int
    f2 := T.Get // f2的类型，也是T类型Get方法的类型：func(t T)int
    fmt.Printf("the type of f1 is %T\n", f1) // the type of f1 is func(*main.T
    fmt.Printf("the type of f2 is %T\n", f2) // the type of f2 is func(main.T)
    f1(&t, 3)
    fmt.Println(f2(t)) // 3
}
```



**巧解难题**：

```go
package main
import (
    "fmt"
    "time"
)
type field struct {
	name string
}
func (p *field) print() {
	fmt.Println(p.name)
}
func main() {
    data1 := []*field{{"one"}, {"two"}, {"three"}}
    for _, v := range data1 {
    	go v.print()
    }
    data2 := []field{{"four"}, {"five"}, {"six"}}
    for _, v := range data2 {
    	go v.print()
    }
    time.Sleep(3 * time.Second)
}
```

部分代码等价于

```go
type field struct {
	name string
}
func (p *field) print() {
	fmt.Println(p.name)
}
func main() {
    data1 := []*field{{"one"}, {"two"}, {"three"}}
    for _, v := range data1 {
    	go (*field).print(v)
    }
    data2 := []field{{"four"}, {"five"}, {"six"}}
    for _, v := range data2 {
   	 	go (*field).print(&v)
    }
    time.Sleep(3 * time.Second)
}
//one
//two
//three
//six
//six
//six
```

改为如下，就可以输入想要的结果：

```go
package main
import (
    "fmt"
    "time"
)
type field struct {
	name string
}
func (p field) print() {
	fmt.Println(p.name)
}
func main() {
    data1 := []*field{{"one"}, {"two"}, {"three"}}
    for _, v := range data1 {
    	go v.print()
    }
    data2 := []field{{"four"}, {"five"}, {"six"}}
    for _, v := range data2 {
    	go v.print()
    }
    time.Sleep(3 * time.Second)
}
//one
//two
//three
//four
//five
//six
```

由 *field 改为 field结果正确的原因是， *field的方法的第一个参数是`*field`， 这个对于 []*field数组直接传入成员就可以了， 而对于[]field数组， 则是要取地址，也就是指针。 但是这个指针指的是for range 循`环的局部变量的地址， 这个地址在for 循环中是不变的， 在for循环结束后这个地址就指向了最后一个元素， goroutine真正实行打印的解引用的地址都是最后一个元素了。



## **receiver 参数类型对 Go 方法的影响**

**直入要害：**

- 当我们的方法 M1 采用类型为 T 的 receiver 参数时，代表 T 类 型实例的 receiver 参数以值传递方式传递到 M1 方法体中的，实际上是 **T 类型实例的副 本**，M1 方法体中对副本的任何修改操作，都不会影响到原 T 类型实例。
- 当我们的方法 M2 采用类型为 *T 的 receiver 参数时，代表 *T 类型实例的 receiver 参数以值传递方式传递到 M2 方法体中的，实际上是 **T 类型实例的地 址**，M2 方法体通过该地址可以对原 T 类型实例进行任何修改操作。



## **类型的方法集合**

**为什么要有方法集合这个概念呢？**

```go
type Interface interface {
    M1()
    M2()
}
type T struct{}
func (t T) M1() {}
func (t *T) M2() {}
func main() {
    var t T
    var pt *T
    var i Interface
    i = pt
    i = t // cannot use t (type T) as type Interface in assignment: T does not
}
```

在这里，我们可以先知道下：**方法集合也是用来判断一个类型是否实现了某接口类型的唯一手段，可以说，“方法 集合决定了接口实现”**



> **什么是类型的方法集合呢？**

**Go 中任何一个类型都有属于自己的方法集合，或者说方法集合是 Go 类型的一个“属性”**。但不是所有类型都有自己的方法呀，比如 int 类型就没有。所以，对于没有定义方 法的 Go 类型，我们称其拥有空方法集合。

 **`dumpMethodSet`**:为了方便查看一个非接口类型的方法集合，我这里提供了一个函数 dumpMethodSet，用 于输出一个非接口类型的方法集合

```go
type T struct{}
func (T) M1() {}
func (T) M2() {}
func (*T) M3() {}
func (*T) M4() {}
func main() {
    var n int
    dumpMethodSet(n)
    dumpMethodSet(&n)
    var t T
    dumpMethodSet(t)
    dumpMethodSet(&t)
}
```

```go
int's method set is empty!
*int's method set is empty!
main.T's method set:
- M1
- M2
*main.T's method set:
- M1
- M2
- M3
- M4
```

**结论**：

- 以 int、*int 为代表的 Go 原生类型由于没有定义方法，所以它们的方法集合都是 空的
- 自定义类型 T 定义了方法 M1 和 M2，因此它的方法集合包含了 M1 和 M2，也符 合我们预期。但 *T 的方法集合中除了预期的 M3 和 M4 之外，居然还包含了类型 T 的方 法 M1 和 M2！

因为：**Go 语言规定，*T 类型的方法集合包含所有以 *T 为 receiver 参数类型的方 法，以及所有以 T 为 receiver 参数类型的方法。**

所以：所谓的**方法集合决定接口实现**的含义就是：如果某类型 T 的方法 集合与某接口类型的方法集合相同，或者类型 T 的方法集合是接口类型 I 方法集合的超 集，那么我们就说这个类型 T 实现了接口 I。或者说，方法集合这个概念在 Go 语言中的主 要用途，就是用来判断某个类型是否实现了某个接口。



## **选择 receiver 参数类型的原则**

在对receiver参数类型做选择前，我们先了解了方法集合概念，以及为什么要有方法集合，接下来直接看原则。



**第一个**：**如果 Go 方法 要把对 receiver 参数代表的类型实例的修改，反映到原类型实例上，那么我们应该选择 *T 作为 receiver 参数的类型。**

可能会有个疑问：如果我们选择了 *T 作为 Go 方法 receiver 参数的类型，那么我们是不是只能通过 *T 类型变量调用该方法，而不能通 过 T 类型变量调用了呢？

**一阵见血**：**无论是 T 类型实例，还是 *T 类型实例，都既 可以调用 receiver 为 T 类型的方法，也可以调用 receiver 为 *T 类型的方法。** Go 编译器在背后做了转换。



**第二个：如果 receiver 参数类型的 size 较大，以值拷贝形式传入就会 导致较大的性能开销，这时我们选择 *T 作为 receiver 类型可能更好些，因为这样的开销只是描述符**。Go 方法调用时，receiver 参数是以值拷贝的 形式传入方法中的



**第三个：T 类型是否需要实现某个接口。**

- 如果 T 类型需要实现某个接口，那我们就要使用 T 作为 receiver 参数的类型，来满足接口 类型方法集合中的所有方法。
- 如果 T 不需要实现某一接口，但 *T 需要实现该接口，那么根据方法集合概念，*T 的方法 集合是包含 T 的方法集合的，这样我们在确定 Go 方法的 receiver 的类型时，参考原则一 和原则二就可以了。



## **独立的自定义类型的方法设计**

**什么是独立的自定义类型呢？就是这个类型的所有方法都是自己显式实现的。**

举个例 子，自定义类型 T 有两个方法 M1 和 M2，如果 T 是一个独立的自定义类型，那我们在声 明类型 T 的 Go 包源码文件中一定可以找到其所有方法的实现代码。

**问题来了**：**难道还有某种自定义类型的方法不是自己显式实现的吗**？当然有！这就 是接下来的重点内容：**如何让某个自定义类型“继承”其他类型的方法实现。**但是我们又知道 **Go 不支持经典的面向对象编程范式吗？怎 么还会有继承这一说法呢？**这里只是借用了“继承”这个词汇而已，说是“继承”，实则 依旧是一种**组合的思想。**

这种组合的思想通过水平组合和垂直组合来完成。这里先了解**垂直组合：类型嵌入**



## **什么是垂直组合：类型嵌入**

类型嵌入指的就是在一个类型的定义中嵌入了其他类型。Go 语言支持两种类型嵌入，分别 是**接口类型的类型嵌入和结构体类型的类型嵌入。**

> **接口类型的嵌入：**

先了解下什么是接口类型的类型嵌入：**接口类 型声明了由一个方法集合代表的接口**，比如下面接口类型 E：

```go
type E interface {
    M1()
    M2()
}
```

这个接口类型 E 的方法集合，包含两个方法，分别是 M1 和 M2，它们组成了 E 这个接口 类型所代表的接口。如果某个类型实现了方法 M1 和 M2，我们就说这个类型实现了 E 所 代表的接口。

此时，我们再定义另外一个接口类型 I，它的方法集合中包含了三个方法 M1、M2 和 M3，如下面代码

```go
type I interface {
    M1()
    M2()
    M3()
}
```

接口类型 I 方法集合中的 M1 和 M2，与接口类型 E 的方法集合中的方法完全相 同。在这种情况下，我们可以用接口类型 E 替代上面接口类型 I 定义中 M1 和 M2，如下 面代码

```go
type I interface {
    E
    M3()
}
```

**接口类型嵌入的语义就是新接口 类型（如接口类型 I）将嵌入的接口类型（如接口类型 E）的方法集合，并入到自己的方法 集合中。**

按 Go 语言惯例，Go 中的接口类型中只包含少量方法，并且常常只是一个方法。通过在接 口类型中嵌入其他接口类型可以实现接口的组合，这也是 **Go 语言中基于已有接口类型构 建新接口类型的惯用法。这也是 Go 组合设计哲学的一种体现。**



> **结构体类型的类型嵌入:**

之前了解的结构体类型是这样的：结构体类型 S 中的每个字段（field）都有唯一的名字与对应的类型，即便是使用空标识符 占位的字段，它的类型也是明确的，但这还不是 Go 结构体类型的“完全体”。

Go 结构体 类型定义还有另外一种形式，那就是**带有嵌入字段（Embedded Field）的结构体定义**

```go
type T1 int
type t2 struct{
    n int
    m int
}
type I interface {
    M1()
}
type S1 struct {
    T1
    *t2
    I
    a int
    b string
}

```

结构体 S1 定义中有三个“非常规形式”的标识符，分别是 T1、t2 和 I，这三 个标识符究竟代表的是什么呢？是字段名还是字段的类型呢？这里我直接告诉你答案：**它 们既代表字段的名字，也代表字段的类型**。**嵌入字段的可见性与嵌入字段的类型的 可见性是一致的**

这种以某个类型名、类型的指针类型名或接口类型名，直接作为结构体字段的方式就叫做 **结构体的类型嵌入**，这些字段也被叫做**嵌入字段（Embedded Field）**



> **嵌入字段的用法**

```go
type MyInt int
func (n *MyInt) Add(m int) {
    *n = *n + MyInt(m)
}
type t struct {
    a int
    b int
}
type S struct {
    *MyInt
    t
    io.Reader
    s string
    n int
}
func main() {
    m := MyInt(17)
    r := strings.NewReader("hello, go")
    s := S{
        MyInt: &m,
        t: t{
        a: 1,
        b: 2,
        },
        Reader: r,
        s: "demo",
    }
	var sl = make([]byte, len("hello, go"))
    s.Reader.Read(sl)
    fmt.Println(string(sl)) // hello, go
	s.MyInt.Add(5)
	fmt.Println(*(s.MyInt)) // 22
}
```

- 第三个嵌入字段的名字为 Reader 而不 是 io.Reader？这是因为，**Go 语言规定如果结构体使用从其他包导入的类型作为嵌入字 段，比如 pkg.T，那么这个嵌入字段的字段名就是 T，代表的类型为 pkg.T。**
- 看结构体类型 S 的变量的初始化。我们使用 field:value 方式对 S 类型的 变量 s 的各个字段进行初始化。和普通的字段一样，初始化嵌入字段时，我们可以直接用 嵌入字段名作为 field。
- 变量 s 使用这些嵌入字段时，我们也可以像普通字段那样直接用变量s+字段选 择符.+嵌入字段的名字，比如 s.Reader。我们还可以通过这种方式调用嵌入字段的方法， 比如 s.Reader.Read 和 s.MyInt.Add。
- Go 还是对嵌入字段有 一些约束的。比如，**和 Go 方法的 receiver 的基类型一样，嵌入字段类型的底层类型不能 为指针类型。**
- 嵌入字段的名字在结构体定义也必须是唯一的，这也意味这如果两个 类型的名字相同，它们无法同时作为嵌入字段放到同一个结构体定义中。



**巧解难题**：带有类型嵌入的结构体 S1 与不带类型嵌入的结构体 S2 是否是等价 的，如不等价，区别在哪里

```go
type S1 struct {
    T1
    *t2
    I
    a int
    b string
}
type S2 struct {
    T1 T1
    t2 *t2
    I I
    a int
    b string
}
```

带有类型嵌入的结构体 S1 就相当于是**继承**。S1结构体能**调用代理**嵌入类型的所有方法

不带类型嵌入的结构体 S2 就相当于是**组合**。S2结构体 是**没有代理**嵌入类型方法。



## **“实现继承”的原理**

我们把上方代码改动部分如下

```go
ar sl = make([]byte, len("hello, go"))
s.Read(sl)
fmt.Println(string(sl))
s.Add(5)
fmt.Println(*(s.MyInt))
```

发现输出正常，且结果和上方一致。这段代码似乎在告诉我们：**Read 方法与 Add 方法就是类型 S 方法集合中的方法**。但是， 这里类型 S 明明没有显式实现这两个方法呀，它是从哪里得到这两个方法的实现的呢？

其实，这两个方法就来自结构体类型 S 的两个嵌入字段 Reader 和 MyInt。结构体类型 S“继承”了 Reader 字段的方法 Read 的实现，也“继承”了 *MyInt 的 Add 方法的实 现。注意，我这里的“继承”用了引号，说明这并不是真正的继承，它只是 Go 语言的一 种“**障眼法**”。

**这种“障眼法”的工作机制是这样的**，当我们通过结构体类型 S 的变量 s 调用 Read 方法 时，Go 发现结构体类型 S 自身并没有定义 Read 方法，于是 Go 会查看 S 的嵌入字段对 应的类型是否定义了 Read 方法。这个时候，Reader 字段就被找了出来，之后 s.Read 的 调用就被转换为 s.Reader.Read 调用。这样一来，嵌入字段 Reader 的 Read 方法就被提升为 S 的方法，**放入了类型 S 的方法集 合**。从外部来看，这 种嵌入字段的方法的提升就给了我们一种结构体类型 S“继承”了 io.Reader 类型 Read 方法的实现，以及 *MyInt 类型 Add 方法的实现的错觉。

所以：**嵌入字段的使用的确可以帮我们在 Go 中实现方法的“继承”。**类型嵌入这种看似“继承”的机制，实际上是一种组合的思想。 更具体点，它是一种**组合中的代理（delegate）模式**，如下图所示

![image-20221115111305855](markdown%E5%9B%BE%E7%89%87/image-20221115111305855.png)

但我们要清楚的是：嵌入字段的类型不同，自定义结构体类型可以代理的方法就不同，那自定义结构体 类型究竟可以代理哪些方法呢？换个角度说，**嵌入字段对结构体的方法集合有哪些影响 呢？**接下来继续了解



## **类型嵌入与类型的方法集合**

**接口类型的类型嵌入的本质，就是嵌入类 型的方法集合并入到新接口类型的方法集合中，并且，接口类型只能嵌入接口类型。**

结 构体类型对嵌入类型的要求就比较宽泛了，可以是任意自定义类型或接口类型。**在这两种情况下，结构体类型的方法集合会有怎样的变化。**



**结构体类型中嵌入接口类型：**

原本结构体类型 T 只带有一个方法 M3，但在嵌入接口类型 I 后，结构体 类型 T 的方法集合中又并入了接口类型 I 的方法集合。并且，由于 *T 类型方法集合包括 T 类型的方法集合，因此无论是类型 T 还是类型 *T，它们的方法集合都包含 M1、M2 和 M3。于是我们可以得出一个结论：**结构体类型的方法集合，包含嵌入的接口类型的方法集 合**。



**易错点：当结构体嵌入的多个接口类型的方法集合存在交 集时，你要小心编译器可能会出现的错误提示**

- **接口类型中嵌入接口类型，有交集不会报错**
- **在结构 体类型中嵌入方法集合有交集的接口类型**，会报错。因为：**嵌入了其他类型的结构体类型本身是一个代理**，在 调用其实例所代理的方法时，Go 会首先查看结构体自身是否实现了该方法。如果实现了，Go 就会优先使用结构体自己实现的方法。如果没有实现，那么 Go 就会查找 结构体中的嵌入字段的方法集合中，是否包含了这个方法。如果多个嵌入字段的方法集合 中都包含这个方法，
- 那么我们就说方法集合存在交集。这个时候，Go 编译器就会因无法确 定究竟使用哪个方法而报错



**结构体类型中嵌入结构体类型：**

有这样一个例子：结构体类型 T 有两个嵌入字段，**分别是 T1 和 *T2**，根据上面对 结构体的方法集合的讲解，我们知道 T1 与 *T1、T2 与 *T2 的方法集合是不同的：

```txt
T1 的方法集合包含：T1M1；
*T1 的方法集合包含：T1M1、PT1M2；
T2 的方法集合包含：T2M1；
*T2 的方法集合包含：T2M1、PT2M2。
```

**它们作为嵌入字段嵌入到 T 中后，对 T 和 *T 的方法集合的影响也是不同的**

```txt
类型 T 的方法集合 = T1 的方法集合 + *T2 的方法集合
类型 *T 的方法集合 = *T1 的方法集合 + *T2 的方法集合
```

**尤其要注意 *T 类型的方法集合，它包含的可不是 T1 类型的方法集合，而是 *T1 类型的方法集合**



讲到这里应该还有一点疑惑：**只有通过类型嵌入才能实现方法“继承”吗**？如果我使用类型声明语 法基于一个已有类型 T 定义一个新类型 NT，那么 NT 是不是可以直接继承 T 的所有方法 呢？

所以接下来继续来看看 defined 类型与 alias 类型是否可以实现方法集合 的“继承”。



## **defined 类型与 alias 类型的方法集合**

Go 语言中，凡通过类型声明语法声明的类型都被称为 **defined 类型**

```go
type I interface {
    M1()
    M2()
}
type T int
type NT T // 基于已存在的类型T创建新的defined类型NT
type NI I // 基于已存在的接口类型I创建新defined接口类型NI
```

- **对于那些基于接口类型创建的 defined 的接口类型，它们的方法集合与原接口类型的方法 集合是一致的**
- 基于自定义非接口类型的 defined 类型的方法集合为空的事实，也决定了即便原类型实现 了某些接口，基于其创建的 defined 类型也没有“继承”这一隐式关联



基于**类型别名**（type alias）定义的新类型有没有“继承”原类型的方法集合呢？

```go
type T struct{}
func (T) M1() {}
func (*T) M2() {}
type T1 = T
func main() {
    var t T
    var pt *T
    var t1 T1
    var pt1 *T1
    dumpMethodSet(t)
    dumpMethodSet(t1)
    dumpMethodSet(pt)
    dumpMethodSet(pt1)
}
```

结论：无论原类型是接口类型还是非接口类型，**类型别名都与原类 型拥有完全相同的方法集合**。



# 接口

接口类型语法与 Go 原生提供 的三个并发原语（Goroutine、channel 与 select），代表了 Go 语言在编程语言领域的创新，更是影响 Go **应用骨架**设计的重要元素。

所谓应用骨架，就是指将应用代码中的业务逻辑、算法实现逻辑、错误处理逻辑等“皮 肉”逐一揭去后所呈现出的应用结构，这就好比下面这个可爱的 Gopher（地鼠）通过 X 光机所看到的骨骼结构：

<img src="markdown%E5%9B%BE%E7%89%87/image-20221116184339242.png" alt="image-20221116184339242" style="zoom:50%;" />

从静态角度去看，我们能清晰地看到 应用程序的组成部分以及各个部分之间的连接；从动态角度去看，我们能看到这幅骨架上 可独立运动的几大机构。 前者我们可以将其理解为 Go 应用内部的耦合设计，而后者我们可以理解为应用的并发设 计。



## **认识接口类型**

**接口类型是由 type 和 interface 关键字定义的一组方法集合，其中，方法集 合唯一确定了这个接口类型所表示的接口。**

```go
type MyInterface interface {
    M1(int) error
    M2(io.Writer, ...string)
}
```

接口类型 MyInterface 所表示的接口的方法集合，包含两 个方法 M1 和 **M2。之所以称 M1 和 M2 为“方法”，更多是从这个接口的实现者的角度 考虑的**。

但从上面接口类型声明中各个“方法”的形式上来看，这更像是不带有 func 关键 字的函数名 + 函数签名（参数列表 + 返回值列表）的组合，它的参数列表不需要写出形参名字，返回值列表也是如此。因此下面的俩种形式表达和上面是一致的。

```go
type MyInterface interface {
	M1(a int) error
    M2(w io.Writer, strs ...string)
}
type MyInterface interface {
    M1(n int) error
    M2(w io.Writer, args ...string)
}
```

**Go 语言要求接口类型声明中的方法必须是具名的，并且方法名字在这个接口类型的 方法集合中是唯一的**（Go 1.14 版本以后，Go 接口 类型允许嵌入的不同接口类型的方法集合存在交集，但前提是交集中的方法不仅名字要一样，它的函数签名部分也要保持一致，也就是参数列表与返回值列表也要相同，否则 Go 编译器照样会报错。）

**在 Go 接口类型的方法集合中放入首字母小写的非导出方法也是合法的**



> **特殊类型：空接口类型**

`type Emptyinterface interface{}`这个方法集合为空的接口类型就被称为空接口类型，但通常我们不需要自己显式定义这类 空接口类型，我们**直接使用interface{}这个类型字面值作为所有空接口类型的代表**就可 以了。



> **声明接口变量：**

接口类型一旦被`type`和`interface`定义后，它就和其他 Go 类型一样可以用于声明变量

```go
var err error //  err是一个error接口类型的实例变量
var r io.Reader // r是一个io.Reade
```

这些类型为接口类型的变量被称为接口类型变量，如果没有被显式赋予初值，接口类型变 量的默认值为 **nil**。如果要为接口类型变量显式赋予初值，我们就要为接口类型变量**选择合法的右值**。

**Go 规定：如果一个类型 T 的方法集合是某接口类型 I 的方法集合的等价集合或超集，我 们就说类型 T 实现了接口类型 I，那么类型 T 的变量就可以作为合法的右值赋值给接口类 型 I 的变量。**

如果**一个变量的类型是空接口类型**，由于空接口类型的方法集合为空，这就意味着任何类 型都实现了空接口的方法集合，所以我们可以将任何类型的值作为右值，赋值给空接口类 型的变量

```go
var i interface{} = 15 // ok
i = "hello, golang" // ok
type T struct{}
var t T
i = t // ok
i = &t // ok
```

**空接口类型的这一可接受任意类型变量值作为右值的特性，让他成为 Go 加入泛型语法之 前唯一一种具有“泛型”能力的语法元素**



> **接口类型变量赋值的“逆操作”：类型断言**

通过接口类型变量“还原”它的右 值的类型与值信息，这个过程被称为“**类型断言**（Type Assertion）”。

**形式一：**

```go
 v, ok := i.(T)
```

 i 是某一个接口类型变量

- 如果 T 是**一个非接口类型且 T 是想要还原的类型**，那么这 句代码的含义就是**断言存储在接口类型变量 i 中的值的类型为 T。**

  如果接口类型变量 i 之前被赋予的值确为 T 类型的值，那么这个语句执行后，左 侧“comma, ok”语句中的变量 ok 的值将为 true，变量 v 的类型为 T，它值会是之前变 量 i 的右值。如果 i 之前被赋予的值不是 T 类型的值，那么这个语句执行后，变量 ok 的值 为 false，变量 v 的类型还是那个要还原的类型，但它的值是类型 T 的零值。

- 如果v, ok := i.(T)中的 **T 是一个接口类型**，那么类型断言的语义就会 变成：**断言 i 的值实现了接口类型 T**。如果断言成功，变量 v 的类型为 i 的值的类型，而并 非接口类型 T。如果断言失败，v 的类型信息为接口类型 T，它的值为 nil



**形式二：**

```go
v := i.(T)
```

这种形式下，一旦接口变量 i 之前被赋予的值不是 T 类型的值，那么这个语句将抛出 panic。如果变量 i 被赋予的值是 T 类型的值，那么变量 v 的类型为 T，它的值就会是之前变量 i 的右值。**由于可能出现 panic，所以我们并不推荐使用这种类型断言的语法形式。**



**变种形式三：type switch**

- **x.(type)**，**这种表达式形式是 switch 语句专有的**，而 且也只能在 switch 语句中使用。这个表达式中的 **x 必须是一个接口类型变量**，表达式的求值结果是这个接口类型变量对应的**动态类型**。

- **`v := x.(type)`，**我们除了可以获得变量 x 的动态类型信息之外，也能获得其动态 类型对应的值信息，现在我们把上面的例子改造一下



## **接口定义的惯例，尽量定义“小接口”**

接口类型的背后，是通过把类型的行为抽象成**契约**，建立双方共同遵守的约定，这种契约 将双方的耦合降到了最低的程度。和生活工作中的契约有繁有简，签署方式多样一样，代 码间的契约也有多有少，有大有小，而且达成契约的方式也有所不同。 而 Go 选择了**去繁 就简**的形式，这主要体现在以下两点上：

- **隐式契约，无需签署，自动生效**：

  Go 语言中接口类型与它的实现者之间的关系是隐式的，不需要像其他语言（比如 Java） 那样要求实现者显式放置“implements”进行修饰，实现者只需要实现接口方法集合中的 全部方法便算是遵守了契约，并立即生效了。

- **更倾向于“小契约”**

  契约太繁杂了就会束缚了手脚，缺少了灵活性，抑制了表现 力。所以 Go 选择了使用“小契约”，表现在代码上就是**尽量定义小接口，即方法个数在 1~3 个之间的接口**。Go 语言之父 Rob Pike 曾说过的“接口越大，抽象程度越弱”



## **小接口有哪些优势？**

**第一点：接口越小，抽象程度越高**

计算机程序本身就是对真实世界的抽象与再建构。抽象就是对同类事物去除它具体的、次 要的方面，抽取它相同的、主要的方面。不同的抽象程度，会导致抽象出的概念对应的事 物的集合不同。**抽象程度越高，对应的集合空间就越大**；抽象程度越低，也就是越具像 化，更接近事物真实面貌，对应的集合空间越小。

**极限恰恰就是无方法的空接口 interface{}，空接口的这个抽象对应的事物集 合空间包含了 Go 语言世界的所有事物。**



**第二点：小接口易于实现和测试**



**第三点：小接口表示的“契约”职责单一，易于复用组合**

**Go 推崇通过组合的方式构建程序**。Go 开发人员一般会尝试通过嵌入其 他已有接口类型的方式来构建新接口类型。

我们会选择那些新接口类型需要的契约职责，同时也要求不要引入我们不需要的契 约职责。在这样的情况下，拥有单一或少数方法的小接口便更有可能成为我们的目标，而 那些拥有较多方法的大接口，可能会因引入了诸多不需要的契约职责而被放弃。由此可 见，小接口更契合 Go 的组合思想，也更容易发挥出组合的威力。



## **定义小接口的遵循法则**

**首先，别管接口大小，先抽象出接口。**

**专注于接口是编写强大而灵活的 Go 代码的关键**。因此，在 定义小接口之前，我们需要先针对**问题领域**进行深入理解，聚焦抽象并发现接口，就像下 图所展示的那样，先针对领域对象的行为进行抽象，形成一个接口集合：

<img src="markdown%E5%9B%BE%E7%89%87/image-20221116192435081.png" alt="image-20221116192435081" style="zoom:67%;" />

**初期，我们先不要介意这个接口集合中方法的数量**，因为对问题域的理解是循序渐进的， 在第一版代码中直接定义出小接口可能并不现实。



**第二，将大接口拆分为小接口。**

有了接口后，我们就会看到接口被用在了代码的各个地方。一段时间后，我们就来分析哪 些场合使用了接口的哪些方法，是否可以将这些场合使用的接口的方法提取出来，放入一 个新的小接口中

<img src="markdown%E5%9B%BE%E7%89%87/image-20221116192710193.png" alt="image-20221116192710193" style="zoom:80%;" />



**最后，我们要注意接口的单一契约职责**

上面已经被拆分成的小接口是否需要进一步拆分，直至每个接口都只有一个方法 呢？这个依然没有标准答案，不过你依然可以考量一下现有小接口是否需要满足单一契约 职责，就像 io.Reader 那样。如果需要，就可以进一步拆分，提升抽象程度。



## **接口的静态特性与动态特性**

**接口的静态特性**体现在**接口类型变量具有静态类型**，比如var err error中变量 err 的静 态类型为 error。拥有静态类型，那就意味着编译器会在编译阶段对所有接口类型变量的赋 值操作进行类型检查，编译器会检查右值的类型是否实现了该接口方法集合中的所有方 法。如果不满足，就会报错

**接口的动态特性**，就体现在接口类型变量在**运行时**还存储了右值的真实类型信息，这个 右值的真实类型被称为接口类型变量的动态类型



**接口的这种“动静皆备”的特性，又带来了什么好处呢?**

接口类型变量在程序运行时可以被赋值为不同的动态类型变量，每次赋值后，接口 类型变量中存储的动态类型信息都会发生变化，这让 Go 语言可以像动态语言（比如 Python）那样拥有使用Duck Typing（鸭子类型）的灵活性。所谓**鸭子类型，就是指某 类型所表现出的特性（比如是否可以作为某接口类型的右值），不是由其基因（比如 C++ 中的父类）决定的，而是由类型所表现出来的行为（比如类型拥有的方法）决定的。**

Duck、Bird、Dog 都是“鸭子类型”，但它们之间并没有什么联系，之所以能作 为右值赋值给 QuackableAnimal 类型变量，只是因为他们表现出了 QuackableAnimal 所要求的特征罢了。**与动态语言不同的是，Go 接口还可以保证“动态特性”使用时的安全性**。比如，编 译器在编译期就可以捕捉到将 int 类型变量传给 QuackableAnimal 接口类型变量这样的 明显错误，决不会让这样的错误遗漏到运行时才被发现。



> ## **nil error 值 != nil**

```go
type MyError struct {
	error
}
var ErrBad = MyError{
	error: errors.New("bad things happened"),
}
func bad() bool {
	return false
}
func returnsError() error {
    var p *MyError = nil
    if bad() {
    	p = &ErrBad
    }
    return p
}
func main() {
    err := returnsError()
    if err != nil {
        fmt.Printf("error occur: %+v\n", err)
        return
    }
    fmt.Println("ok")
}
//error occur: <nil>
```

为什么nil error值 ！= nil,我们需要弄懂接口类型变量的内部表示。

先说答案：从 returnsError 返回的 error 接口类型变量 err 的数据指针虽然为空，但它的类型信息 （iface.tab）并不为空，而是 *MyError 对应的类型信息，这样 err 与 nil（0x0,0x0）相 比自然不相等

怎么改呢？：

- 把returns Error（）里面p的类型改为error
- 删除p，直接retrun nil 
- 把returnsError（）类型改为*MyError



## **接口类型变量的内部表示**

接口类型“动静兼备”的特性也决定了它的变量的内部表示绝不像一个静态类型变量（如 int、float64）那样简单，我们可以在$GOROOT/src/runtime/runtime2.go中找到接 口类型变量在运行时的表示

```go
// $GOROOT/src/runtime/runtime2.go
type iface struct {
    tab *itab
    data unsafe.Pointer
}
type eface struct {
    _type *_type
    data unsafe.Pointer
}
```

在运行时层面，接口类型变量有两种内部表示：iface和eface，这两种表示 分别用于不同的接口类型变量：

- **eface** 用于表示没有方法的空接口（empty interface）类型变量，也就是 interface{}类 型的变量； 
- **iface** 用于表示其余拥有方法的接口 interface 类型变量。
- **共同点**：都有两个指针字段，并且第二个指针字段的功能相同，都是**指 向当前赋值给该接口类型变量的动态类型变量的值**。
- 不同点：
  -  eface 表示的空接口类型并没有方法列表，因此它的第一 个指针字段指向一个_type类型结构，这个结构为**该接口类型变量的动态类型的信息**
  - iface 除了要存储**动态类型信息**之外，还要存储**接口本身的信息**（接口的类型信息、方 法列表信息等）以及动态类型所实现的方法的信息(包路径名（pkgpath）和接口方法集合切片)，因此 iface 的第一个字段指向一个 itab类型结构



> **实例之eface运行时表示：**

```go
type T struct {
    n int
    s string
}
func main() {
    var t = T {
   		n: 17,
    	s: "hello, interface",
    }
    var ei interface{} = t // Go运行时使用eface结构表示ei
}
```

这个例子中的空接口类型变量 ei 在 Go 运行时的表示是这样的:

<img src="markdown%E5%9B%BE%E7%89%87/image-20221117095624850.png" alt="image-20221117095624850" style="zoom: 80%;" />



> **实例之iface运行时表示：**

```go
type T struct {
	n int
	s string
}
func (T) M1() {}
func (T) M2() {}
type NonEmptyInterface interface {
    M1()
    M2()
}
func main() {
    var t = T{
   		n: 18,
    	s: "hello, interface",
    }
    var i NonEmptyInterface = t
}
```

NonEmptyInterface 接口类型变量在 Go 运行时表示的示意图：

![image-20221117095814130](markdown%E5%9B%BE%E7%89%87/image-20221117095814130.png)

**总结**：每个接口类型变量在**运行时的表示**都是由两部分组成 的，针对**不同接口类型我们可以简化记作：eface(_type, data)和iface(tab, data)。**

- 虽然 eface 和 iface 的第一个字段有所差别，但 tab 和 _type 可以统一看作是动态 类型的类型信息。Go 语言中每种类型都会有唯一的 _type 信息，无论是内置原生类型，还 是自定义类型都有。Go 运行时会为程序内的全部类型建立只读的共享 _type 信息表，因此 **拥有相同动态类型的同类接口类型变量的 _type/tab 信息是相同的。**
- 接口类型变量的 data 部分则是指向一个动态分配的内存空间，这个内存空间存储的是赋 值给接口类型变量的动态类型变量的值。**未显式初始化的接口类型变量的值为nil，也就是 这个变量的 _type/tab 和 data 都为 nil。**

**我们判断两个接口类型变量是否相同，只需要判断 _type/tab 是否相同，以及 data 指针指向的内存空间所存储的数据值是否相同就可以了。这里要注意不是 data 指针 的值相同噢**。



## **如何比较接口类型变量**

通过肉眼去辨别接口类型变量是否相等总是困难一些，我们可以引入一些 **helper 函 数**。借助这些函数，我们可以清晰地输出接口类型变量的内部表示，这样就可以一目了然 地看出两个变量是否相等

eface 和 iface 是 runtime 包中的非导出结构体定义，我们不能直接在包外使用，所 以也就无法直接访问到两个结构体中的数据。不过，Go 语言提供了 println 预定义函数， 可以用来输出 eface 或 iface 的两个指针字段的值。 在编译阶段，编译器会根据要输出的参数的类型将 println 替换为特定的函数，这些函数都 定义在$GOROOT/src/runtime/print.go文件中，而针对 eface 和 iface 类型的打印函 数实现如下：

```go
// $GOROOT/src/runtime/print.go
func printeface(e eface) {
	print("(", e._type, ",", e.data, ")")
}
func printiface(i iface) {
	print("(", i.tab, ",", i.data, ")")
}
```



> **第一种：nil 接口变量**

**未赋初值的接口类型变量的值为 nil**，这类变量也就是 nil 接口变量，我们 来看这类变量的内部表示输出的例子

```
func printNilInterface() {
    // nil接口变量
    var i interface{} // 空接口类型
    var err error // 非空接口类型
    println(i)
    println(err)
    println("i = nil:", i == nil)
    println("err = nil:", err == nil)
    println("i = err:", i == err)
}
//(x0,0x0)
//(x0,0x0)
//i= nil: true
//err = nil: true
//i = err: true
```

**无论是空接口类型还是非空接口类型变量**，一旦变量值为 **nil(未显式初始化)**，那么它们内部表 示均为(0x0,0x0)，也就是类型信息、数据值信息均为空。因此上面的变量 **i 和 err 等值 判断为 true。**

所以在这种情况下会有**nil error值== nil**。请记住，**除非我们只声明而不初始化，或者显式地赋给它`nil`，否则接口变量的值就不会为`nil`。**



> **第二种：空接口类型变量**

```go
func printEmptyInterface() {
    var eif1 interface{} // 空接口类型
    var eif2 interface{} // 空接口类型
    var n, m int = 17, 18
    eif1 = n
    eif2 = m
    println("eif1:", eif1)//eif1: (0x10ac580,0xc00007ef48)
    println("eif2:", eif2)//eif2: (0x10ac580,0xc00007ef40)
    println("eif1 = eif2:", eif1 == eif2) // false
    eif2 = 17
    println("eif1:", eif1)//eif1: (0x10ac580,0xc00007ef48)
    println("eif2:", eif2//eif2: (0x10ac580,0x10eb3d0)
    println("eif1 = eif2:", eif1 == eif2) // true
    eif2 = int64(17)
    println("eif1:", eif1)//eif1: (0x10ac580,0xc00007ef48)
    println("eif2:", eif2)//eif2: (0x10ac640,0x10eb3d8)
    println("eif1 = eif2:", eif1 == eif2) // false
}
```

**对于空接口类型变量，只有 _type 和 data 所指数据内 容一致的情况下，两个空接口类型变量之间才能划等号。**

Go **在创建 eface 时一般会 为 data 重新分配新内存空间**，将动态类型变量的值复制到这块内存空间，并将 data 指针 指向这块内存空间。因此我们多数情况下看到的 **data 指针值都是不同的**。



> **第三种：非空接口类型变量**

```go
type T int
func (t T) Error() string {
    return "bad error"
}
func printNonEmptyInterface() {
    var err1 error // 非空接口类型
    var err2 error // 非空接口类型
    err1 = (*T)(nil)
    println("err1:", err1)//err1: (0x10ed120,0x0)
    println("err1 = nil:", err1 == nil)//err1 = nil: false
    err1 = T(5)
    err2 = T(6)
    println("err1:", err1)//err1: (0x10ed1a0,0x10eb310)
    println("err2:", err2)//err2: (0x10ed1a0,0x10eb318)
    println("err1 = err2:", err1 == err2)//err1 = err2: false
    err2 = fmt.Errorf("%d\n", 5)
    println("err1:", err1)//err1: (0x10ed1a0,0x10eb310)
    println("err2:", err2)//err2: (0x10ed0c0,0xc000010050)
    println("err1 = err2:", err1 == err2)//err1 = err2: false
}
```

上面示例中每一轮通过 println 输出的 err1 和 err2 的 tab 和 data 值，要么 data 值不同，要么 tab 与 data 值都不同。

**和空接口类型变量一样，只有 tab 和 data 指的数据内容一致的情况下，两个非空接口类 型变量之间才能划等号。**



> **第四种：空接口类型变量与非空接口类型变量的等值比较**

```go
func printEmptyInterfaceAndNonEmptyInterface() {
    var eif interface{} = T(5)
    var err error = T(5)
    println("eif:", eif)//eif: (0x10b3b00,0x10eb4d0)
    println("err:", err)//err: (0x10ed380,0x10eb4d8)
    println("eif = err:", eif == err)//eif = err: true
    err = T(6)
    println("eif:", eif)//eif: (0x10b3b00,0x10eb4d0)
    println("err:", err)//err: (0x10ed380,0x10eb4e0)
    println("eif = err:", eif == err)//eif = err: false
}
```

空接口类型变量和非空接口类型变量内部表示的结构有所不同（第一个字 段：_type vs. tab)，两者似乎一定不能相等。但 Go 在进行等值比较时，类型比较使用的 是 eface 的 _type 和 iface 的 tab._type，因此就像我们在这个例子中看到的那样，当 eif 和 err 都被赋值为T(5)时，两者之间是划等号的。



## **接口类型的装箱(boxing)原理**

**装箱**（boxing）是编程语言领域的一个基础概念，**一般是指把一个值类型转换成引用类 型**，比如在支持装箱概念的 Java 语言中，将一个 int 变量转换成 Integer 对象就是一个装 箱操作。

**在 Go 语言中，将任意类型赋值给一个接口类型变量也是装箱操作**。有了前面对接口类型 变量内部表示的学习，我们知道**接口类型的装箱实际就是创建一个 eface 或 iface 的过 程。** **装箱操作是由 Go 编译器和运行时共 同完成的**，有一定的性能开销，对于性能敏感的系统来说，我们应该尽量避免或减少这类 装箱操作。



## **Go语言面向对象设计：一切皆组合**

在弄清楚接口是什么这个问题之后，摆在我们面前的就是**怎么用接口**的问题 了。学习如何利用接口进行应用的设计，以及改善已有应用的设计，换 句话说就是 **Go 接口的应用模式或惯例。**

但先要了解一个前置原则，那就是在**实际真正需要的 时候才对程序进行抽象**。再通俗一些来讲，就是**不要为了抽象而抽象。**

在多数情况下，在真实的生产项目中，接口都能给应用设计带来好处。那么如果要用接 口，我们应该怎么用呢？怎么借助接口来改善程序的设计，让系统实现我们常说的高内聚 和低耦合呢？这就要从 **Go 语言的“组合”的设计哲学说起**



Go 语言之父 Rob Pike 曾说过：如果 C++ 和 Java 是关于类型层次结构和类型分类的语 言，那么 **Go 则是关于组合的语言**。



在计算机技术中，**正交性用于表示某种不相依赖性或是解耦性**。如果两个或更多事物中的 一个发生变化，不会影响其他事物，那么这些事物就是正交的

**编程语言的语法元素间和语言特性也存在着正交的情况，并且通过将这些正交的特性组合 起来，我们可以实现更为高级的特性。**在语言设计层面，Go 语言就为广大 Gopher 提供 了诸多**正交的语法元素**供后续组合使用，包括：

- Go 语言无类型体系（Type Hierarchy），没有父子类的概念，类型定义是正交独立 的；
-  方法和类型是正交的，每种类型都可以拥有自己的方法集合，方法本质上只是一个将 receiver 参数作为第一个参数的函数而已； 
- 接口与它的实现者之间无“显式关联”，也就说接口与 Go 语言其他部分也是正交的。**接口作为 Go 语言提供的具有天然正交性的语法元素**



构建 Go 应用程序的静态骨架结构有两**种主要的组合方式**
![image-20221117110533862](markdown%E5%9B%BE%E7%89%87/image-20221117110533862.png)

- **垂直组合**：垂直组合更多用在将多个类型（如上图中的 T1、I1 等）通过“**类型嵌入（Type Embedding）**”的方式实现新类型（如 NT1）的定义。
  - 传统面向对象编程语言（比如：C++）大多是通过继承的方式建构出自己的类型体系的， 但 Go 语言并没有类型体系的概念。Go 语言通过类型的组合而不是继承让单一类型**承载更 多的功能**。由于这种方式与硬件配置升级的垂直扩展很类似，所以这里我们叫它**垂直组 合**。
  - **这样的垂直组合更多应用在新类型的定义方面**。通过这种垂直组合，我们可以达到方法实 现的复用、接口定义重用等目的。
    - 第一种：通过嵌入接口构建接口
    - 第二种：通过嵌入接口构建结构体类型
    - 第三种：通过嵌入结构体类型构建新结构体类型：代理委派模式
- **水平组合**：了整个应用程序骨架 中的“器官”，比如手、手臂等，那么这些“器官”之间又是通过什么连接在一起的呢？ **关节!也就是接口！**



## **接口应用的几种模式(设计模式)**

通过接口进行水平组合的基本模式就是：**使用 接受接口类型参数的函数或方法**。在这个基本模式基础上，还有其他几种“衍生品”。



**基本模式**：

```go
func YourFuncName(param YourInterfaceType)
```

![image-20221117111157170](markdown%E5%9B%BE%E7%89%87/image-20221117111157170.png)

函数 / 方法参数中的接口类型作为“关节（连接点）”，支持将位于多个包中 的多个类型与 YourFuncName 函数连接到一起，共同实现某一新特性。

同时，接口类型和它的实现者之间隐式的关系却在不经意间满足了：依赖抽象（DIP）、里 氏替换原则（LSP）、接口隔离（ISP）等代码设计原则，这在其他语言中是需要很“刻 意”地设计谋划的，但对 Go 接口来看，这一切却是自然而然的。



**创建模式：**

Go 社区流传一个经验法则：“接受接口，返回结构体（Accept interfaces, return structs）”，这其实就是一种把接口作为“关节”的应用模式。我这里把它叫做创建模 式，是因为这个经验法则多用于创建某一结构体类型的实例。

创建模式通过接口，在 **NewXXX 函数所在包与接口的实现者所在包之间建立了一个连接**。 大多数包含接口类型字段的结构体的实例化，都可以使用创建模式实现。



**包装器模式：**

```go
func YourWrapperFunc(param YourInterfaceType) YourInterfaceType
```

实现对输入参数的类型的包装，并在不改变被包装类型（输入参 数类型）的定义的情况下，返回具备新功能特性的、实现相同接口类型的新类型。这种接 口应用模式我们叫它包装器模式，也叫装饰器模式。包装器多用于对输入数据的过滤、变 换等操作。



**适配器模式：**

适配器模式的核心是适配器函数类型（Adapter Function Type）。适配器函数类型是一 个辅助水平组合实现的“工具”类型。这里我要再强调一下，**它是一个类型**。它可以将一 个满足特定函数签名的普通函数，显式转换成自身类型的实例，转换后的实例同时也是某 个接口类型的实现者。



**中间件：**

中间件（Middleware）这个词的含义可大可 小。在 Go Web 编程中，“中间件”常常指的是一个实现了 http.Handler 接口的 http.HandlerFunc 类型实例。**实质上，这里的中间件就是包装模式和适配器模式结合的产 物。**

**最后需要我们牢记的是：我们要尽量避免使用空接口作为函数参数类型。一旦使用空接口 作为函数参数类型，你将失去编译器为你提供的类型安全保护屏障。**



# 泛型

2022 年 3 月 Go 1.18 版本的泛型落地以及 8 月份 Go 1.19 对泛型问题的一轮修复后，是时候开始 Go 泛型了。

首先了解下Go泛型设计方案明确不支持的若干特性：

- 不支持泛型特（specialization），即不支持编写一个泛型函数针对某个具体类型的特殊版本；
- 不支持元编程（metaprogramming），即不支持编写在编译时执行的代码来生成在运行时执行的代码；
- 不支持操作符方法（operator method），即只能用普通的方法（method）操作类型实例（比如：getIndex(k)），而不能将操作符视为方法并自定义其实现，比如一个容器类型的下标访问 c[k]；
- 不支持变长的类型参数（type parameters）；
- … …

## **为什么要加入泛型**

**“泛型编程的中心思想是对具体的、高效的算法进行抽象，以获得通用的算法，然后这些算法可以与不同的数据表示法结 合起来，产生各种各样有用的软件”**。说白了就是**将算法与类型解耦，实现算法更广泛的 复用。**

为什么要加入呢：内置比较大小的函数。

在没有泛型之前，Gopher 们通常使用空接口类型 interface{}，作为算法操作的对象的数 据类型，不过这样做的不足之处也很明显：一是无法进行类型安全检查，二是性能有损 失。

**既然泛型有这么多优点，为什么 Go 不早点加入泛型呢**

- 这个语法特性不紧迫，不是 Go 早期的设计目标；
- 与简单的设计哲学有悖；
- 尚未找到合适的、价值足以抵消其引入的复杂性的理想设计方案。



## **Go泛型的演化简史**

早期Russ Cox觉得实现Go泛型的三个slow：

- **拖慢程序员**：不实现泛型，不会引入复杂性，但就像前面例子中那样，需要程序员花费 精力重复实现 AddInt、AddInt64 等； 
- **拖慢编译器**：就像 C++ 的泛型实现方案那样，通过增加编译器负担为每个类型实例生 成一份单独的泛型函数的实现，这种方案产生了大量的代码，其中大部分是多余的，有 时候还需要一个好的链接器来消除重复的拷贝； 
- **拖慢执行性能**：就像 Java 的泛型实现方案那样，通过隐式的装箱和拆箱操作消除类型差 异，虽然节省了空间，但代码执行效率低。

2017年：Russ Cox 在 GopherCon 2017 大会上发表演讲，正 式吹响 Go 向下一个阶段演化的号角，包括重点解决泛型、包依赖以及错误处理等 Go 社 区最广泛关注的问题。

在 2018 年 8 月，也就是 GopherCon 2018 大会结束后不久，Go 核心团队发布了 Go2 draft proposal，这里面涵盖了由伊恩·泰勒和罗伯特·格瑞史莫操刀主写的 Go 泛型的 第一版 draft proposal。这版设计草案引入了 contract 关键字来定义泛型类型参数（type parameter）的约束、 类型参数放在普通函数参数列表前面的小括号中，并用 type 关键字声明。

2019 年 7 月，伊恩·泰勒在 GopherCon 2019 大会上发表演讲“Why Generics?”，并更新了泛型的技术草案，简化了 contract 的语法设计

2020 年 6 月，一篇叫《Featherweight Go》论文发表在 arxiv.org 上，这篇 论文出自著名计算机科学家、函数语言专家、Haskell 语言的设计者之一、Java 泛型的设 计者菲利普 - 瓦德勒（PHILIP WADLER）之手。Rob Pike 邀请他参加 Go 核心团队解决 Go 语言的泛型扩展问题，这篇论文就是菲利普 - 瓦德 对这次邀请的回应。这篇论文为 Go 语言的一个最小语法子集设计了泛型语法 Featherweight Generic Go（FGG），并成功地给出了 FGG 到 Feighterweight Go（FG）的可行性实现的形式化 证明。

2020 年 6 月末，伊恩·泰勒和罗伯特·格瑞史莫在 Go 官方博客发表了文章《The Next Step for Generics》，介绍了 Go 泛型工作的最新进展，Go 团队放弃了引入 contract 关键字作为泛型类型参数的约束，而 采用扩展后的 interface 来替代 contract

在 2020 年 11 月的 GopherCon 2020 大会，罗伯特·格瑞史莫与全世界的 Gopher 同步了 Go 泛型的最新进展和 roadmap，在最新的技术草案版本中，包裹类型参数的小括 号被方括号取代，类型参数前面的 type 关键字也不再需要了

2021 年 4 月，伊恩·泰勒在 GitHub 上发布issue，提议去除原 Go 泛型方案中置 于 interface 定义中的 type list 中的 type 关键字，并引入 **type set** 的概念

在 2021 年 12 月 14 日，Go 1.18 beta1 版本发布，这个版本包含了对 Go 泛型 的正式支持。经过 12 年的努力与不断地自我否定，Go 团队终于将泛型引入到 Go 中，并且经过缜密设 计的语法**并没有违背 Go1 的兼容性**



## **为什么要加入泛型的实际场景**

在聚焦 Go 泛型的基本语法：**类型参数**之前，先了解一个最常见的泛型应用场景

例子：返回切片中值最大的元素。这个例子要实现一个函数，该函数接受一个切片作为输入参数，然后返回该切片中值最大的那个元素。题目并没有明确使用什么元素类型的切片，我们就先以最常见的整型切片为例，实现一个 maxInt 函数：

```go
// max_int.go
func maxInt(sl []int) int { 
    if len(sl) == 0 { 
        panic("slice is empty")
    } 

    max := sl[0]
    for _, v := range sl[1:] { 
        if v > max { 
            max = v 
        } 
    } 
    return max
}

func main() {
    fmt.Println(maxInt([]int{1, 2, -4, -6, 7, 0})) // 输出：7
}
```

现在给它加一个新需求：能否针对元素为 string 类型的切片返回其最大（按字典序）的元素值呢？

```go
// max_string.go
func maxString(sl []string) string {
    if len(sl) == 0 {
        panic("slice is empty")
    }

    max := sl[0]
    for _, v := range sl[1:] {
        if v > max {
            max = v
        }
    }
    return max
}

func main() {
    fmt.Println(maxString([]string{"11", "22", "44", "66", "77", "10"})) // 输出：77
}
```

问题来了！有代码洁癖的同学肯定已经嗅到了上面2个函数散发的“糟糕味道”：代码重复。上面2个函数除了切片的元素类型不同，其他逻辑都一样。

那么能否实现一个“通用”的函数，可以处理上面三种元素类型的切片呢？提到“通用”，你一定想到了 Go 语言提供的 any（interface{}的别名）

```go
// max_any.go
func maxAny(sl []any) any {
    if len(sl) == 0 {
        panic("slice is empty")
    }

    max := sl[0]
    for _, v := range sl[1:] {
        switch v.(type) {
        case int:
            if v.(int) > max.(int) {
                max = v
            }
        case string:
            if v.(string) > max.(string) {
                max = v
            }
        case float64:
            if v.(float64) > max.(float64) {
                max = v
            }
        }
    }
    return max
}

func main() {
    i := maxAny([]any{1, 2, -4, -6, 7, 0})
    m := i.(int)
    fmt.Println(m) // 输出：7
    fmt.Println(maxAny([]any{"11", "22", "44", "66", "77", "10"})) // 输出：77
    fmt.Println(maxAny([]any{1.01, 2.02, 3.03, 5.05, 7.07, 0.01})) // 输出：7.07
}
```

maxAny 利用 any、type switch 和类型断言（type assertion）实现了我们预期的目标。不过这个实现并不理想，它**至少有如下几个问题**：

- 若要支持其他元素类型的切片，我们需**对该函数进行修改；**
- maxAny 的返回值类型为 any（interface{}），要得到其实际类型的值还需要通过**类型断言转换**；
- 使用 any（interface{}）作为输入参数的元素类型和返回值的类型，由于存在装箱和拆箱操作，其性能与 maxInt 等比起来要**逊色不少**



在 Go 1.18 版本之前，Go 的确没有比较理想的解决类似上述“通用”问题的手段，直到 Go 1.18 版本泛型落地后，我们可以用泛型语法实现 maxGenerics 函数

```go
// max_generics.go
type ordered interface {
    ~int | ~int8 | ~int16 | ~int32 | ~int64 |
        ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 | ~uintptr |
        ~float32 | ~float64 |
        ~string
}

func maxGenerics[T ordered](sl []T) T {
    if len(sl) == 0 {
        panic("slice is empty")
    }

    max := sl[0]
    for _, v := range sl[1:] {
        if v > max {
            max = v
        }
    }
    return max
}

type myString string

func main() {
    var m int = maxGenerics([]int{1, 2, -4, -6, 7, 0})
    fmt.Println(m) // 输出：7
    fmt.Println(maxGenerics([]string{"11", "22", "44", "66", "77", "10"})) // 输出：77
    fmt.Println(maxGenerics([]float64{1.01, 2.02, 3.03, 5.05, 7.07, 0.01})) // 输出：7.07
    fmt.Println(maxGenerics([]int8{1, 2, -4, -6, 7, 0})) // 输出：7
    fmt.Println(maxGenerics([]myString{"11", "22", "44", "66", "77", "10"})) // 输出：77
}
```

从功能角度看，泛型版本的 maxGenerics 实现了预期的特性

- 对于 ordered 接口中声明的那些原生类型以及以这些原生类型为底层类型（underlying type）的类型（比如示例中的 myString），maxGenerics 都可以无缝支持

- maxGenerics 返回的类型与传入的切片的元素类型一致，调用者也无需通过类型断言做转换。

- 通过性能基准测试我们也可以看出，与 maxAny 相比，泛型版本的 maxGenerics 性能要好很多，但与原生版函数如 maxInt 等还有差距

  ```go
  go test -v -bench . ./max_test.go max_any.go max_int.go
  ```



## **类型参数（type parameters）**

**Go 泛型方案的实质是对类型参数（type parameter）的支持**，包括：

- **泛型函数**（generic function）：带有类型参数的函数；
- **泛型类型**（generic type）：带有类型参数的自定义类型；
- **泛型方法**（generic method）：泛型类型的方法。

> **泛型函数**

先以泛型函数为例来具体说明一下什么是类型参数。

上面的maxGenerics 就是一个泛型函数，看一下 maxGenerics 的函数原型：

```go
func maxGenerics[T ordered](sl []T) T {
    // ... ...
}
```

maxGenerics 这个函数与我们之前学过的普通 Go 函数（ordinary function）相比，至少有**两点不同**：

- maxGenerics 函数在函数名称与函数参数列表之间多了一段由**方括号**括起的代码：[T ordered]；
  - go语言范型不使用 <>，是解析的时候 容易与大于 或者小于 符号混淆
- maxGenerics 参数列表中的参数类型以及返回值列表中的返回值类型都是 T，而不是某个具体的类型

**类型参数列表**：maxGenerics 函数原型中多出的这段代码[T ordered]就是 Go 泛型的**类型参数列表**（type parameters list），示例中这个列表中仅有一个**类型参数 T**，ordered 为类型参数的**类型约束**（type constraint）。**类型约束之于类型参数，就好比常规参数列表中的类型之于常规参数**

- 按 Go 惯例，类型参数名的**首字母通常采用大写形式**

- 在同一个类型参数列表中，类型参数**名字也要唯一**

- 和常规参数类似，泛型函数中类型参数也**有其作用域范围**，这个范围从类型参数列表左侧的方括号[开始，一直持续到函数体结束

- 并且类型参数必须是**具名**的，即便你在后续的函数参数列表、返回值列表和函数体中没有使用该类型参数

  ```go
  func print[T any]() { // 正确
  }     
  func print[any]() {   // 编译错误：all type parameters must be named 
  }
  ```



> **调用泛型函数：**

先了解下**类型形参和类型实参**：和普通函数有形式参数与实际参数一样，类型参数也有类型形参（type parameter）和类型实参（type argument）之分。其中**类型形参就是泛型函数声明中的类型参数**，以前面示例中的 maxGenerics 泛型函数为例，如下面代码，**maxGenerics 的类型形参就是 T，而类型实参则是在调用 maxGenerics 时实际传递的类型 int**

```go
// 泛型函数声明：T为类型形参
func maxGenerics[T ordered](sl []T) T

// 调用泛型函数：int为类型实参
m := maxGenerics[int]([]int{1, 2, -4, -6, 7, 0})
```

在调用泛型函数时，除了要传递**普通参数列表对应的实参**之外，还要**显式传递类型实参**，比如这里的 int。并且，显式传递的类型实参要放在函数名和普通参数列表前的方括号中。

但这样会对调用**产生一个问题**：如果泛型函数的类型形参较多，那么逐一显式传入类型实参会让泛型函数的调用显得十分冗长。Go 团队的泛型实现者们也考虑了这个问题，并给出了解决方法：**函数类型实参的自动推断**

**这个机制就是通过判断传递的函数实参的类型来推断出类型实参的类型，从而允许开发者不必显式提供类型实参，**下面是以 maxGenerics 函数为例的类型实参推断过程示意图：

![image-20221117160711415](markdown%E5%9B%BE%E7%89%87/image-20221117160711415.png)

当 maxGenerics 函数传入的实际参数为[]int{…}时，Go 编译器会将其类型[]int 与泛型函数参数列表中对应参数的类型（[]T）作比较，并推断出 T == int 这一结果。当然这个例子的推断过程较为简单，那些有难度的，甚至无法肉眼可见的就交给 Go 编译器去处理吧

- 这个**类型实参自动推断有一个前提，你一定要记牢，那就是它必须是函数的参数列表中使用了的类型形参(不过在约束的类型推断中证明也可以不使用，但有个前提！)**，否则就会像下面的示例中的代码，编译器将报无法推断类型实参的错误：

```go
func foo[T comparable, E any](a int, s E) {
}

foo(5, "hello") // 编译器错误：cannot infer T
```

- **切记：不能通过返回值类型来推断类型实参。**

  ```go
  func foo[T any](a int) T {
      var zero T
      return zero
  }
  
  var a int = foo(5) // 编译器错误：cannot infer T
  println(a)
  ```



> **泛型函数调用过程:**

```go
maxGenerics([]int{1, 2, -4, -6, 7, 0})
```

上面代码是对 maxGenerics 泛型函数的一次调用，Go 对这段泛型函数调用代码的处理分为两个阶段，如下图所示：![image-20221117161307211](markdown%E5%9B%BE%E7%89%87/image-20221117161307211.png)

可以用一种更形象的方式来描述上述泛型函数的实例化过程。实例化就**好比一家生产“求最大值”机器的工厂**，它会根据要比较大小的对象的类型将这样的机器生产出来。以上面的例子来说，整个实例化过程如下：

- 工厂接单：调用 maxGenerics([]int{…})，工厂师傅发现要比较大小的对象类型为 int；
- 模具检查与匹配：检查 int 类型是否满足模具的约束要求，即 int 是否满足 ordered 约束，如满足，则将其作为类型实参替换 maxGenerics 函数中的类型形参 T，结果为 maxGenerics[int]；
- 生产机器：将泛型函数 maxGenerics 实例化为一个**新函数**，这里将其起名为 maxGenericsInt，其函数原型为 **func([]int)int**。本质上 **maxGenericsInt := maxGenerics[int]**。

**另外要注意，当我们使用相同类型实参对泛型函数进行多次调用时，Go 仅会做一次实例化，并复用实例化后的函数**



> **泛型类型**

Go 对类型参数的另一类支持：**带有类型参数的自定义类型，即泛型类型。**比如下面代码中的 maxableSlice：

```go
// maxable_slice.go

type maxableSlice[T ordered] struct {
    elems []T
}
```

maxableSlice 是一个自定义切片类型，这个类型的特点是总可以获取其内部元素的最大值，其唯一的要求是其内部元素是可排序的，**它通过带有 ordered 约束的类型参数来明确这一要求**

**在泛型类型中**

- **类型参数列表**放在类型名字后面的方括号中
- 和泛型函数一样，泛型类型可以有多个类型参数
- 类型参数名通常是首字母大写的
- 这些类型参数也必须是具名的，且命名唯一
- 和泛型函数中类型参数有其作用域一样，泛型类型中类型参数的作用域范围也是从类型参数列表左侧的方括号[开始，一直持续到类型定义结束的位置其一般形式如下

```go
type TypeName[T1 constraint1, T2 constraint2, ..., Tn constraintN] TypeLiteral
```



下面是一些自定义泛型类型的示例：

```go

type Set[T comparable] map[T]struct{}

type sliceFn[T any] struct {
  s   []T
  cmp func(T, T) bool
}

type Map[K, V any] struct {
  root    *node[K, V]
  compare func(K, K) int
}

type element[T any] struct {
  next *element[T]
  val  T
}

type Numeric interface {
  ~int | ~int8 | ~int16 | ~int32 | ~int64 |
    ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 | ~uintptr |
    ~float32 | ~float64 |
    ~complex64 | ~complex128
}

type NumericAbs[T Numeric] interface {
  Abs() T
}
```

- **泛型类型中的类型参数可以用来作为类型声明中字段的类型**
- 如果要在泛型类型声明的内部引用该类型名，必须要带上类型参数，如上面的 element 结构体中的 next 字段的类型：*element[T]
- 如果泛型类型有不止一个类型参数，那么在其声明内部引用该类型名时，不仅要带上所有类型参数，类型参数的顺序也要与声明中类型参数列表中的顺序一致



> **使用泛型类型：**

和泛型函数一样，使用泛型类型时也会有一个实例化（instantiation）过程，比如

```go
type maxableSlice[T ordered] struct {
    elems []T
}

var sl = maxableSlice[int]{
    elems: []int{1, 2, -4, -6, 7, 0},
} 
```

Go 会根据传入的类型实参（int）生成一个新的类型并创建该类型的变量实例，sl 的类型等价于下面代码：

```go

type maxableIntSlice struct {
    elems []int
}
```

**泛型类型是否可以像泛型函数那样实现类型实参的自动推断呢？很遗憾，目前的 Go 1.19 尚不支持**



> **泛型类型与类型别名：**

**类型别名与其绑定的原类型是完全等价的，但这仅限于原类型是一个直接类型，即可直接用于声明变量的类型**。

```go
type foo[T1 any, T2 comparable] struct {
    a T1
    b T2
}
  
type fooAlias = foo // 编译器错误：cannot use generic type foo[T1 any, T2 comparable] without instantiation
```

**泛型类型只是一个生产真实类型的“工厂”，它自身在未实例化之前是不能直接用于声明变量的，因此不符合类型别名机制的要求。泛型类型只有实例化后才能得到一个真实类型，也就是说泛型函数的类型、泛型类型的类型只有在实例化之后参能确定！！！**，例如下面的代码就是合法的

````go
type fooAlias = foo[int, string]
````

**也就是说，我们只能为泛型类型实例化后的类型创建类型别名**



> **泛型类型与类型嵌入：**

引入泛型类型之后，我们依然可以在泛型类型定义中

- 嵌入普通类型
- 也可以将**其他泛型类型实例化后的类型**作为成员

```go
type Lockable[T any] struct {
    t T
    sync.Mutex
}

func (l *Lockable[T]) Get() T {
    l.Lock()
    defer l.Unlock()
    return l.t
}

func (l *Lockable[T]) Set(v T) {
    l.Lock()
    defer l.Unlock()
    l.t = v
}
```

```go
type Slice[T any] []T
  
func (s Slice[T]) String() string {
    if len(s) == 0 {
        return ""
    }
    var result = fmt.Sprintf("%v", s[0])
    for _, v := range s[1:] {
        result = fmt.Sprintf("%v, %v", result, v)
    }
    return result
}

type Lockable[T any] struct {
    t T
    Slice[int]
    sync.Mutex
}

func main() {
    n := Lockable[string]{
        t:     "hello",
        Slice: []int{1, 2, 3},
    }
    println(n.String()) // 输出：1, 2, 3
}
```

**在普通类型定义中，我们也可以使用实例化后的泛型类型作为成员**

```go
type Foo struct {
    Slice[int]
}

func main() {
    f := Foo{
        Slice: []int{1, 2, 3},
    }
    println(f.String()) // 输出：1, 2, 3
}
```

此外，Go 泛型设计方案支持在泛型类型定义中嵌入类型参数作为成员，比如下面的泛型类型 Lockable 内嵌了一个类型 T，且 T 恰为其类型参数

```go
type Lockable[T any] struct {
    T
}
```



> **泛型方法**

Go 类型可以拥有自己的方法（method），泛型类型也不例外，**为泛型类型定义的方法称为泛型方法（generic method**

```go
func (sl *maxableSlice[T]) max() T {
    if len(sl.elems) == 0 {
        panic("slice is empty")
    }

    max := sl.elems[0]
    for _, v := range sl.elems[1:] {
        if v > max {
            max = v
        }
    }
    return max
}
```

在定义泛型类型的方法时，方法的 receiver 部分不仅要带上类型名称，还需要带上完整的类型形参列表（如 maxableSlice[T]），这些类型形参**后续可以用在方法的参数列表和返回值列表中。**



在 Go 泛型目前的设计中，**泛型方法自身**不可以再支持类型参数了，不能像下面这样定义泛型方法：

```go
func (f *foo[T]) M1[E any](e E) T { // 编译器错误：syntax error: method must have no type parameters
    //... ...
}
```



在泛型方法中，**receiver 中某个类型参数如果没有在方法参数列表和返回值中使用，可以用“_”代替，但不能不写**，比如：

```go

type foo[A comparable, B any] struct{}

func (foo[A, B]) M1() { // ok
}

或

func (foo[_, _]) M1() { // ok
}

或

func (foo[A, _]) M1() { // ok
}

但

func (foo[]) M1() { // 错误：receiver部分缺少类型参数

}
```

另外，泛型方法中的 receiver 中类型参数名字可以与泛型类型中的类型形参名字不同，位置和数量对上即可

```go

type foo[A comparable, B any] struct{}

func (foo[First, Second]) M1(a First, b Second) { // First对应类型参数A，Second对应类型参数B

}
```



## **泛型约束**

虽然泛型是开发人员表达“通用代码”的一种重要方式，但这并**不意味着所有泛型代码对所有类型都适用**。更多的时候，我们需要对**泛型函数的类型参数**以及**泛型函数中的实现代码**设置限制。泛型函数调用者只能传递满足限制条件的类型实参，泛型函数内部也只能以**类型参数允许的方式**使用这些类型实参值。在 Go 泛型语法中，我们使用**类型参数约束**（type parameter constraint）（以下简称约束）来表达这种限制条件。

**约束之于类型参数就好比函数参数列表中的类型之于参数**

![image-20221118105124833](markdown%E5%9B%BE%E7%89%87/image-20221118105124833.png)

函数普通参数在函数实现代码中可以表现出来的性质与可以参与的运算**由参数类型限制**，而泛型函数的类型参数就**由约束（constraint）来限制**

2018 年 8 月的 Go 泛型第一版设计方案中，Go 引入了 contract 关键字来定义泛型类型参数的约束。但经过约两年的 Go 社区公示和讨论，转而采用已有的 interface 类型来替代 contract 定义约束。使用 interface 类型作为约束的定义方法能够最大程度地复用已有语法，并抑制语言引入泛型后的复杂度。但原有的 interface 语法尚不能满足定义约束的要求。所以，**在 Go 泛型版本中，interface 语法也得到了一些扩展**，这也是约束被认为是 Go 泛型的一个难点的原因。



> **Go原生内置约束**

**最宽松的约束any：**

无论是泛型函数还是泛型类型，其所有类型参数声明中都必须**显式包含约束**，即便你允许类型形参接受所有类型作为类型实参传入也是一样。那么我们如何表达“所有类型”这种约束呢？我们可以使用**空接口类（interface{}）**来作为类型参数的约束。不过使用 interface{}作为约束至少有以下几点“不足”：

- 如果存在多个这类约束时，泛型函数声明部分会显得很冗长，比如上面示例中的 doSomething 的声明部分；
- interface{}包含{}这样的符号，会让本已经很复杂的类型参数声明部分显得更加复杂；
- 和 comparable、Sortable、ordered 这样的约束命名相比，interface{}作为约束的表意不那么直接。

Go 团队在 Go 1.18 泛型落地的同时又引入了一个预定义标识符：any。any 本质上是 interface{}的一个类型别名：

```go
// $GOROOT/src/builtin/buildin.go
// any is an alias for interface{} and is equivalent to interface{} in all ways.
type any = interface{}
```



在函数体内，使用 any 约束的形参 T 可以用来做如下操作：

- 声明变量；

- 同类型赋值；

- 将变量传给其他函数或从函数返回；

- 取变量地址；

- 转换或赋值给 interface{}类型变量；

- 用在类型断言或 type switch 中；

- 作为复合类型中的元素类型；

- 传递给预定义的函数，比如 new。

  ```go
  // any.go
  func doSomething[T1, T2 any](t1 T1, t2 T2) T1 {
      var a T1        // 声明变量
      var b T2
      a, b = t1, t2   // 同类型赋值
      _ = b
  
      f := func(t T1) {
      }
      f(a)            // 传给其他函数
  
      p := &a         // 取变量地址
      _ = p
  
      var i interface{} = a  // 转换或赋值给interface{}类型变量
      _ = i
  
      c := new(T1)    // 传递给预定义函数
      _ = c
  
      f(a)            // 将变量传给其他函数
  
      sl := make([]T1, 0, 10) // 作为复合类型中的元素类型
      _ = sl
  
      j, ok := i.(T1) // 用在类型断言中
      _ = ok
      _ = j
  
      switch i.(type) { // 作为type switch中的case类型
          case T1:
          case T2:
      }
      return a        // 从函数返回
  }
  ```

  但如果对 any 约束的类型参数进行了非上述允许的操作**，比如相等性或不等性比较**，那么 Go 编译器就会报错：

  ```go
  // any.go
  
  func doSomething[T1, T2 any](t1 T1, t2 T2) T1 {
      var a T1 
      if a == t1 { // 编译器报错：invalid operation: a == t1 (incomparable types in type set)
      }
      
      if a != t1 { // 编译器报错：invalid operation: a != t1 (incomparable types in type set)
      }
      ... ...
  }
  ```

  所以说，如果我们想在泛型函数体内部对类型参数声明的变量实施相等性（==）或不等性比较（!=）操作，我们就需要更换约束，这就引出了 **Go 内置的另外一个预定义约束：comparable。**



**支持比较操作的内置约束comparable:**

```go
// $GOROOT/src/builtin/buildin.go

// comparable is an interface that is implemented by all comparable types
// (booleans, numbers, strings, pointers, channels, arrays of comparable types,
// structs whose fields are all comparable types).
// The comparable interface may only be used as a type parameter constraint,
// not as the type of a variable.
type comparable interface{ comparable }
```

Go 编译器会在编译期间判断某个类型是否实现了 comparable 接口。所有可比较的类型都实现了 comparable 这个接口，包括：布尔类型、数值类型、字符串类型、指针类型、**channel** 类型、元素类型实现了 comparable 的数组和成员类型均实现了 comparable 接口的结构体类型

```go
// comparable.go

type foo struct {
    a int
    s string
}

type bar struct {
    a  int
    sl []string
}

func doSomething[T comparable](t T) T {
    var a T
    if a == t {
    }
    
    if a != t {
    }
    return a
}   
    
func main() {
    doSomething(true)
    doSomething(3)
    doSomething(3.14)
    doSomething(3 + 4i)
    doSomething("hello")
    var p *int
    doSomething(p)
    doSomething(make(chan int))
    doSomething([3]int{1, 2, 3})
    doSomething(foo{})
    doSomething(bar{}) //  bar does not implement comparable
}
```

最后一行 bar 结构体类型因为内含不支持比较的切片类型，被 Go 编译器认为未实现 comparable 接口，但除此之外的其他类型作为类型实参都满足 comparable 约束的要求。

**注意**，comparable 虽然也是一个 interface，但它不能像普通 interface 类型那样来用，比如下面代码会导致编译器报错：

```go
var i comparable = 5 // 编译器错误：cannot use type comparable outside a type constraint: interface is (or embeds) comparable
```

**comparable 只能用作修饰类型参数的约束。**



> **自定义约束**

Go 泛型最终决定使用 interface 语法来定义约束。这样一来，**凡是接口类型均可作为类型参数的约束。**下面是一个使用**普通接口类型**作为类型参数约束的示例：

```go
// stringify.go

func Stringify[T fmt.Stringer](s []T) (ret []string) {
    for _, v := range s {
        ret = append(ret, v.String())
    }
    return ret
}

type MyString string

func (s MyString) String() string {
    return string(s)
}

func main() {
    sl := Stringify([]MyString{"I", "love", "golang"})
    fmt.Println(sl) // 输出：[I love golang]
}
```

使用的是 fmt.Stringer 接口作为约束。

- 一方面，这要求类型参数 T 的实参必须实现 fmt.Stringer 接口的所有方法；
- 另一方面，泛型函数 Stringify 的实现代码中，声明的 T 类型实例（比如 v）也仅被允许调用 fmt.Stringer 的 String 方法。

这类**基于行为（方法集合）定义的约束**对于习惯了 Go 接口类型的开发者来说，是相对好理解的，定义和使用起来，与下面这样的以接口类型作为形参的普通 Go 函数相比，区别似乎不大：

```go
func Stringify(s []fmt.Stringer) (ret []string) {
    for _, v := range s {
        ret = append(ret, v.String())
    }
    return ret
}
```

想扩展一下上面 stringify.go 这个示例，将 Stringify 的语义改为只处理非零值的元素：

```go
// stringify_without_zero.go

func StringifyWithoutZero[T fmt.Stringer](s []T) (ret []string) {
    var zero T
    for _, v := range s {
        if v == zero { // 编译器报错：invalid operation: v == zero (incomparable types in type set)
            continue
        }
        ret = append(ret, v.String())
    }
    return ret
}
```

针对 v 的相等性判断导致了编译器报错，我们需要**为类型参数赋予更多的能力**，比如支持相等性和不等性比较。这让我们想起了我们刚刚学过的 Go 内置约束 comparable,comparable 虽然不能像普通接口类型那样声明变量，但它却可以**作为类型嵌入到其他接口类型中**。

```go
// stringify_new_without_zero.go
type Stringer interface {
    comparable
    String() string
}

func StringifyWithoutZero[T Stringer](s []T) (ret []string) {
    var zero T
    for _, v := range s {
        if v == zero {
            continue
        }
        ret = append(ret, v.String())
    }
    return ret
}

type MyString string

func (s MyString) String() string {
    return string(s)
}

func main() {
    sl := StringifyWithoutZero([]MyString{"I", "", "love", "", "golang"}) // 输出：[I love golang]
    fmt.Println(sl)
}
```

在这个示例里，我们自定义了一个 Stringer 接口类型作为约束。在该类型中，我们不仅定义了 String 方法，还嵌入了 comparable，这样在泛型函数中，我们用 Stringer 约束的类型参数就具备了进行相等性和不等性比较的能力了。

还要为之加上对排序行为的支持，并基于排序能力实现下面的 StringifyLessThan 泛型函数：

```go
func StringifyLessThan[T Stringer](s []T, max T) (ret []string) {
    var zero T
    for _, v := range s {
        if v == zero || v >= max {
            continue
        }
        ret = append(ret, v.String())
    }
    return ret
}
```

会得到编译器的报错信息：“invalid operation: v >= max (type parameter T is not comparable with >=)”。Go 编译器认为 Stringer 约束的**类型参数 T 不具备排序比较能力**。

Go 核心团队显然也想到了这一点，于是对 Go 接口类型声明语法做了扩展，**支持在接口类型中放入类型元素（type element）信息**

```go
type ordered interface {
  ~int | ~int8 | ~int16 | ~int32 | ~int64 |
  ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 | ~uintptr |
  ~float32 | ~float64 | ~string
}
```

这个接口类型的声明中，我们没有看到任何方法，取而代之的是一组由竖线“|”分隔的、带着小尾巴“~”的类型列表。这个列表表示的是，**以它们为底层类型（underlying type）的类型都满足 ordered 约束**，都可以作为以 ordered 为约束的类型参数的类型实参，传入泛型函数。

```go
type Stringer interface {
    ordered
    comparable
    String() string
}

func main() {
    sl := StringifyLessThan([]MyString{"I", "", "love", "", "golang"}, MyString("cpp")) // 输出：[I]
    fmt.Println(sl)
}
```



**通过自定义约束再次总结Go 接口类型语法**：

![image-20221118112739059](markdown%E5%9B%BE%E7%89%87/image-20221118112739059.png)

新的接口类型

- 依然可以嵌入其他接口类型，满足组合的设计哲学；

- 除了嵌入的其他接口类型外，其余的组成元素被称为**接口元素**（interface element）。接口元素也有两类，

  - 一类就是常规的方法元素（method element），每个方法元素对应一个方法原型；

  - 另一类则是此次扩展新增的类型元素（type element），即在接口类型中，我们可以放入一些类型信息，就像前面的 ordered 接口那样。

    - 类型元素可以是单个类型，也可以是一组由竖线“|”连接的类型，竖线“|”的含义是“并”，这样的一组类型被称为 union element。无论是单个类型，还是 union element 中由“|”分隔的类型，如果类型中不带有“~”符号的类型就代表其自身；而**带有“~”符号的类型则代表以该类型为底层类型 (underlying type) 的所有类型**，这类带有“~”的类型也被称为 approximation element

      ```go
      
      type Ia interface {
        int | string  // 仅代表int和string
      }
      
      type Ib interface {
        ~int | ~string  // 代表以int和string为底层类型的所有类型
      }
      ```

    - 不过要注意的是：**union element 中不能包含带有方法元素的接口类型，也不能包含预定义的约束类型，如 comparable**。

**总结：扩展后，Go 将接口类型分成了两类**

- 一类是基本接口类型（basic interface type），即其自身和其嵌入的接口类型都只包含方法元素，而不包含类型元素。基本接口类型不仅可以当做常规接口类型来用，即声明接口类型变量、接口类型变量赋值等，还可以作为泛型类型参数的约束。
- 除此之外的非空接口类型都属于**非基本接口类型，即直接或间接（通过嵌入其他接口类型）包含了类型元素的接口类型**。这类接口类型**仅可以用作泛型类型参数的约束**，或**被嵌入**到其他**仅作为约束的接口类型中**

```go

type BasicInterface interface { // 基本接口类型
    M1()
}

type NonBasicInterface interface { // 非基本接口类型
    BasicInterface
    ~int | ~string // 包含类型元素
}

type MyString string

func (MyString) M1() {
}  
   
func foo[T NonBasicInterface](a T) { // 非基本接口类型作为约束
}  
   
func bar[T BasicInterface](a T) { // 基本接口类型作为约束
}  
   
func main() {
    var s = MyString("hello")
    var bi BasicInterface = s // 基本接口类型支持常规用法
    var nbi NonBasicInterface = s // 非基本接口不支持常规用法，导致编译器错误：cannot use type NonBasicInterface outside a type constraint: interface contains type constraints
    bi.M1()
    nbi.M1()
    foo(s)
    bar(s)           
}
```

**问题进村了**：

基本接口类型，由于其**仅包含方法元素**，我们依旧可以基于之前讲过的**方法集合**，来确定一个类型是否实现了接口，以及**是否可以作为类型实参传递给约束下的类型形参。**

但对于**只能作为约束的非基本接口类型**，既有方法元素，也有类型元素，我们如何判断一个类型是否满足约束，并作为类型实参传给类型形参呢？

这时我们就要介绍 Go 泛型落地时引入的新概念：**类型集合（type set）**，类型集合将作为后续判断类型是否满足约束的基本手段。



> **类型集合(type set)**

结合 Go 泛型设计方案以及Go 语法规范，我们可以这么来理解**类型集合**：

- 每个类型都有一个类型集合；
- **非接口类型的类型**的类型集合中仅包含其自身，比如非接口类型 T，它的类型集合为{T}，即集合中仅有一个元素且这唯一的元素就是它自身。
- **空接口类型**（any 或 interface{}）的类型集合是一个无限集合，该集合中的元素为所有非接口类型这个与我们之前的认知也是一致的，所有非接口类型都实现了空接口类型；
- **非空接口类型的类型集合**则是**其定义中接口元素的类型集合的交集(有可能接口元素一个都没有：这种情况的接口类型只有方法集合的概念)**。**接口元素**可以是**其他嵌入接口**类型，可以是**常规方法元素**，也可以是**类型元素**。
  - 当接口元素为其他嵌入接口类型时，该接口元素的类型集合就为该嵌入接口类型的类型集合；
  - 而当接口元素为常规方法元素时，接口元素的类型集合就为**该方法的类型集合。**
    - Go 规定一个方法的类型集合为所有实现了该方法的非接口类型的集合，这显然也是一个无限集合
    - 也可以合理解释仅包含多个方法的常规接口类型的类型集合，那就是这些方法元素的类型集合的交集，即所有实现了这三个方法的类型所组成的集合。
  - 类型元素的类型集合相对来说是最好理解的，每个类型元素的类型集合就是其表示的所有类型组成的集合。如果是~T 形式，则集合中不仅包含 T 本身，还包含所有以 T 为底层类型的类型。如果使用 Union element，则类型集合是所有竖线“|”连接的类型的类型集合的并集。

![image-20221118134216747](markdown%E5%9B%BE%E7%89%87/image-20221118134216747.png)

```go
type Intf1 interface {
    ~int | string
  F1()
  F2()
}

type Intf2 interface {
  ~int | ~float64
}

type I interface {
    Intf1 
    M1()
    M2()
    int | ~string | Intf2
}
```

接口类型 I 由四个**接口元素**组成，分别是 Intf1、M1、M2 和 Union element “int | ~string | Intf2”，我们只要分别求出这四个元素的类型集合，再取一个交集即可

- **Intf1 的类型集合**

  Intf1 是接口类型 I 的一个嵌入接口，它自身也是由三个接口元素组成，它的类型集合为这三个接口元素的交集，即{以 int 为底层类型的所有类型、string、实现了 F1 和 F2 方法的所有类型}。

- **M1 和 M2 的类型集合**

  方法的类型集合是由所有实现该方法的类型组成的，因此 M1 的方法集合为{实现了 M1 的所有类型}，M2 的方法集合为{实现了 M2 的所有类型}。

- **int | ~string | Intf2 的类型集合**

  这是一个类型元素，它的类型集合为 int、~string 和 Intf2 方法集合的并集。int 类型集合就是{int}，~string 的类型集合为{以 string 为底层类型的所有类型}，而 Intf2 的方法集合为{以 int 为底层类型的所有类型，以 float64 为底层类型的所有类型}。

上面集合的交集，也就是**{以 int 为底层类型的且实现了 F1、F2、M1、M2 这个四个方法的所有类型}**

```go
// typeset.go

func doSomething[T I](t T) {
}

type MyInt int

func (MyInt) F1() {
}
func (MyInt) F2() {
}
func (MyInt) M1() {
}
func (MyInt) M2() {
}

func main() {
    var a int = 11
    //doSomething(a) //int does not implement I (missing F1 method)

    var b = MyInt(a)
    doSomething(b) // ok
}
```

如上代码，我们定义了一个以 int 为底层类型的自定义类型 MyInt 并实现了四个方法，这样 MyInt 就满足了泛型函数 doSomething 中约束 I 的要求，可以作为类型实参传递



**简化版的约束形式**

泛型参数的约束都是一个完整的接口类型，要么是独立定义在泛型函数外面（比如下面代码中的 I 接口），要么以接口字面值的形式，直接放在类型参数列表中对类型参数进行约束，比如下面示例中 doSomething2 类型参数列表中的接口类型字面值：

```go
type I interface { // 独立于泛型函数外面定义
    ~int | ~string
}

func doSomething1[T I](t T)
func doSomething2[T interface{~int | ~string}](t T) // 以接口类型字面值作为约束
```



在约束对应的接口类型中**仅有一个接口元素，且该元素为类型元素**时，Go 提供了**简化版**的约束形式，我们不必将约束独立定义为一个接口类型，比如上面的 doSomething2 可以简写为下面简化形式：

```go]
func doSomething2[T ~int | ~string](t T) // 简化版的约束形式
```

**简化版的一般形式**就是：这种简化形式也可以理解为一种**类型约束的语法糖。**

```go
func doSomething[T T1 | T2 | ... | Tn](t T) 
```



**简化版的特殊情况**：定义仅包含一个类型参数的泛型类型时，如果约束中仅有一个 *int 型类型元素，我们使用上述简化版形式就会有问题，比如

```go
type MyStruct [T * int]struct{} // 编译错误：undefined: T
                                // 编译错误：int (type) is not an expression
```

当遇到这种情况时，Go 编译器会将该语句理解为一个类型声明：MyStruct 为新类型的名字，而其底层类型为[T * int]struct{}，即一个元素为空结构体类型的数组

**解决方案**：

- 一种是用完整形式的约束：`type MyStruct[T interface{*int}] struct{}`
- 另外一种则是在简化版约束的 *int 类型后面加上一个逗号：`type MyStruct[T *int,] struct{} `



> **约束的类型推断**

在上面，我们提到了在大多数情况下，我们都可以使用**类型推断**避免在**调用泛型函数时显式传入类型实参**，Go 泛型可以根据泛型函数的实参推断出类型实参

但当我们遇到下面示例中的泛型函数时，光依靠函数类型实参的推断是无法完全推断出所有类型实参的

```go
func DoubleDefined[S ~[]E, E constraints.Integer](s S) S {
```

因为像 DoubleDefined 这样的泛型函数，其类型参数 E 在其常规参数列表中并未被用来声明输入参数，函数类型实参推断仅能根据传入的 s 的类型，推断出类型参数 S 的类型实参，E 是无法推断出来的

所以为了**进一步避免开发者显式传入类型实参**，Go 泛型支持了**约束类型推断**（constraint type inference），即**基于一个已知的类型实参（已经由函数类型实参推断判断出来了）**，来推断其他类型参数的类型。我们还以上面 DoubleDefined 这个泛型函数为例，当通过实参推断得到类型 S 后，Go 会尝试启动约束类型推断来推断类型参数 E 的类型。但你可能也看出来了，约束类型推断可成功应用的**前提是 S 是由 E 所表示的**。



## **明确泛型使用时机**

Go 当初没有及时引入泛型的一个原因就是泛型与 Go 语言“简单”的设计哲学有悖，现在加入了泛型，**Go 核心团队以及 Go 社区却又开始担心“泛型被滥用”。**

> **何时适合使用泛型？**

Go 泛型语法体现在**类型参数**上，所以说，类型参数适合的场景就是适合应用泛型编程的时机。

**一阵见血**：**如果你发现自己多次编写完全相同的代码，其中副本之间的唯一区别是代码使用不同的类型，那么可考虑使用类型参数了。**

**场景一：编写通用数据结构时:**

在 Go 尚不支持泛型的时候，如果要实现一个通用的数据结构，比如一个先入后出的 stack 数据结构，我们通常有两个方案。

- 第一种方案是为每种要使用的元素类型单独实现一套栈结构，会有**大量的重复代码**。
- 第二种方案是使用 interface{}实现通用数据结构。

下面是用 Go 泛型实现一个 stack 数据结构的示例代码：

```go
// stack.go
package stack

type Stack[T any] []T

func (s *Stack[T]) Top() (t T) {
    l := len(*s)
    if l == 0 {
        return t
    }
    return (*s)[l-1]
}

func (s *Stack[T]) Push(v T) {
    (*s) = append((*s), v)
}

func (s *Stack[T]) Len() int {
    return len(*s)
}

func (s *Stack[T]) Pop() (T, bool) {
    var zero T
    if len(*s) < 1 {
        return zero, false
    }

    // Get the last element from the stack.
    result := (*s)[len(*s)-1]

    // Remove the last element from the stack.
    *s = (*s)[:len(*s)-1]

    return result, true
}
```

如果非要说和 IntStack、StringStack 等的差异，那可能就是在执行性能上要差一些了`go test -bench .`



**场景二：函数操作的是 Go 原生的容器类型时:**

如果函数具有切片、map 或 channel 这些 Go 内置容器类型的参数，并且函数代码未对容器中的元素类型做任何特定假设，那我们使用类型参数可能很有帮助。

```go
// max_generics.go
type ordered interface {
    ~int | ~int8 | ~int16 | ~int32 | ~int64 |
        ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 | ~uintptr |
        ~float32 | ~float64 |
        ~string
}

func maxGenerics[T ordered](sl []T) T {
    if len(sl) == 0 {
        panic("slice is empty")
    }
    
    max := sl[0]
    for _, v := range sl[1:] {
        if v > max {
            max = v
        }
    }
    return max
}
```

类型参数使得此类**容器算法与容器内元素类型彻底解耦**。在没有泛型语法之前，实现这样的函数通常需要使用反射。不过使用反射，会让代码可读性大幅下降，编译器也无法做静态类型检查，并且运行时开销也大得很。



**场景三：不同类型实现一些方法的逻辑相同时：**

在 Go 编码过程中，我们经常会遇到这样一种情况：**某个函数接受一个自定义接口类型作为参数**

```go
type MyInterface interface {
    M1()
    M2()
    M3()
}

func doSomething(i MyInterface) {
}
```

当这些类型实现 M1、M2 和 M3 的逻辑看起来都相同时，我们就可以使用类型参数来帮助实现 M1~M3 这些方法了，下面就是通过类型参数实现这些方法的通用逻辑代码（实际逻辑做了省略处理）

```go
// common_method.go

type commonMethod[T any] struct{}
  
func (commonMethod[T]) M1() {}
func (commonMethod[T]) M2() {}
func (commonMethod[T]) M3() {}

func main() {
    var intThings commonMethod[int]
    var stringThings commonMethod[string]
    doSomething(intThings)
    doSomething(stringThings)
}

或

func doSomethingCM[T any]() {
    doSomething(commonMethod[T]{})
}

func main() {
    doSomethingCM[int]()
    doSomethingCM[string]()
}
```

其实，Go 标准库的 sort.Sort 就是这样的情况，其参数类型为 sort.Interface，而 sort.Interface 接口中定义了三个方法

```go
// $GOROOT/src/sort/sort.go
func Sort(data Interface)

type Interface interface {
  Len() int
  Less(i, j int) bool
  Swap(i, j int)
}
```

所有实现 sort.Interface 类型接口的类型，在实现 Len、Less 和 Swap 这三个通用方法的逻辑看起来都相同，比如 sort.go 中提供的 StringSlice 和 IntSlice 两种类型的三个方法的实现如下：

```go
type StringSlice []string

func (x StringSlice) Len() int           { return len(x) }
func (x StringSlice) Less(i, j int) bool { return x[i] < x[j] }
func (x StringSlice) Swap(i, j int)      { x[i], x[j] = x[j], x[i] }

type IntSlice []int

func (x IntSlice) Len() int           { return len(x) }
func (x IntSlice) Less(i, j int) bool { return x[i] < x[j] }
func (x IntSlice) Swap(i, j int)      { x[i], x[j] = x[j], x[i] }
```



## **Go泛型原理简介**

假使你目前遇到的场景适合使用泛型，你可能依然会犹豫要不要使用泛型，因为你还不清楚泛型对代码执行性能的影响。特别是在一些性能敏感的系统中，这一点尤为重要。那么如何知道泛型对执行性能的影响呢？这就要从 Go 泛型实现原理说起了。

Russ Cox 提出了 Go 面对泛型可遵循的三个路径以及每个路径的不足，也就是三个 slow（拖慢）：

- **C 语言路径**：不实现泛型，不会引入复杂性，但这会“拖慢程序员”，因为可能需要程序员花费精力做很多重复实现；
- **C++ 语言路径**：就像 C++ 的泛型实现方案那样，通过增加编译器负担为每个类型实参生成一份单独的泛型函数的实现，这种方案产生了大量的代码，其中大部分是多余的，有时候还需要一个好的链接器来消除重复的拷贝，显然这个实现路径会“拖慢编译器”；
- **Java 路径**：就像 Java 的泛型实现方案那样，通过隐式的装箱和拆箱操作消除类型差异，虽然节省了空间，但代码执行效率低，即“拖慢执行性能”。

Go 核心团队在评估 Go 泛型实现方案时是非常谨慎的，负责泛型实现设计的Keith Randall 博士一口气提交了三个实现方案，供大家讨论和选择：

- **Stenciling 方案**：Stenciling 方案也称为模板方案（如上图）， 它也是 C++、Rust 等语言使用的实现方案。其主要思路就是在编译阶段，根据泛型函数调用时类型实参或约束中的类型元素，为每个实参类型或类型元素中的类型生成一份单独实现，**拖慢编译器**。这么说还是很抽象，下图很形象地说明了这一过程：

  <img src="markdown%E5%9B%BE%E7%89%87/image-20221118150236688.png" alt="image-20221118150236688" style="zoom:50%;" />

- **Dictionaries 方案**；与 Stenciling 方案的实现思路正相反，它不会为每个类型实参单独创建一套代码，反之它仅会有一套函数逻辑，但这个函数会多出一个参数 dict，这个参数会作为该函数的第一个参数，这和 Go 方法的 receiver 参数在方法调用时自动作为第一个参数有些类似。这个 dict 参数中保存泛型函数调用时的类型实参的类型相关信息。它对**性能**可能有比较大的影响。下面是 Dictionaries 方案的示意图：

  <img src="markdown%E5%9B%BE%E7%89%87/image-20221118150346248.png" alt="image-20221118150346248" style="zoom:50%;" />

- **Go 最终采用的方案：GC Shape Stenciling 方案**。GC Shape Stenciling 方案顾名思义，它基于 Stenciling 方案，但又没有为所有类型实参生成单独的函数代码，而是**以一个类型的 GC shape 为单元进行函数代码生成。**一个类型的 GC shape 是指该类型在 Go 内存分配器 / 垃圾收集器中的表示，这个表示由类型的大小、所需的对齐方式以及类型中包含指针的部分所决定。

  这样一来势必就有 GC shape 相同的类型共享一个实例化后的函数代码，那么泛型调用时又是如何区分这些类型的呢？答案就是**字典**。该方案同样在每个实例化后的函数代码中自动增加了一个 dict 参数，用于区别 GC shape 相同的不同类型。可见，GC Shape Stenciling 方案本质上是 Stenciling 方案和 Dictionaries 方案的混合版



**泛型对执行效率的影响：**Go 泛型实现选择了一条折中的路线：既没有选择纯 Stenciling 方案，避免了对 Go 编译性能带去较大影响，也没有选择像 Java 那样泛型那样的纯装箱和拆箱方案，给运行时带去较大开销。

好消息是：在 Go 1.20 版本中，由于将使用 Unified IR（中间代码表示）替换现有的 IR 表示，Go 泛型函数的执行性能将得到进一步优化



# Go杂谈

## Go迭代版本新增特性

### 1.17

> **新的语法特性**

**支持将切片转换为数组指针**

通过数组切片化， 我们可以将一个数组转换为切片。转换后，数组将成为转换后的切片的底层数组，通过切 片，我们可以直接改变数组中的元素。

在 Go 1.17 版本之前，Go 并不支持将切片再转换回数组类型。当 然，如果你非要这么做也不是没有办法，我们可以通过 unsafe 包以不安全的方式实现这样 的转换，如下面代码所示：

```go
b := []int{11, 12, 13}
var p = (*[3]int)(unsafe.Pointer(&b[0]))
p[1] += 10
fmt.Printf("%v\n", b) // [11 22 13]
```

但是 unsafe 包，正如其名，它的安全性没有得到编译器和 runtime 层的保证，只能由开 发者自己保证

在 Go 1.17 版本中，我们可以像下面代码这样将一个切片转换为数组类型指针，不 用再借助 unsafe 包的“黑魔法”了：

```go
b := []int{11, 12, 13}
p := (*[3]int)(b) // 将切片转换为数组类型指针
p[1] = p[1] + 10
fmt.Printf("%v\n", b) // [11 22 13]
```

**要注意的是**，Go 会通过运行时而不是编译器去对这类切片到数组指针的转换 代码做检查，如果发现越界行为，就会触发运行时 panic。Go 运行时实施检查的一条原则 就是“**转换后的数组长度不能大于原切片的长度**”，注意这里是切片的长度（len），而不 是切片的容量（cap）。



> **Go Module的变化**

**修剪module依赖图**

Go 1.17 版本中，Go Module 最重要的一个变化就是 **pruned module graph，即修剪 的 module 依赖图。**

**完整的module依赖图：**在 Go 1.17 之前的版本中，某个 module 的依赖图是由这个 module 的直接依赖以及所有 间接依赖组成的。这样，无论某个间接依赖是否真正为原 module 的构建做出贡献，Go 命令在解决依赖时都会读取每个依赖的 go.mod，包括那些没有被真正使用到的 module，这样形成的 module 依赖图被称为**完整 module 依赖图**

从 Go 1.17 的版本开始，Go 不再使用“完整 module 依赖图”，而是引入了 pruned module graph，也就是修剪的 module 依赖图。修剪的 module 依赖图就是在完整 module 依赖图的基础上，将那些对构建完全没有“贡献”的间接依赖 module 修剪掉 后，剩余的依赖图。使用修剪后的 module 依赖图进行构建，有助于避免下载或阅读那些 不必要的 go.mod 文件，这样 Go 命令可以不去获取那些不相关的依赖关系，从而在日常 开发中节省时间。

![image-20221121104008727](markdown%E5%9B%BE%E7%89%87/image-20221121104008727.png)

但 module 依赖图修剪也带来了一个副作用，那就是 go.mod 文件 size 的变大。因为从 Go 1.17 版本开始，每次调用 go mod tidy，Go 命令都会对 main module 的依赖做一次 深度扫描（deepening scan），并将 main module 的所有直接和间接依赖都记录在go.mod 中。考虑到依赖的内容较多，go 1.17 会将直接依赖和间接依赖分别放在多个不 同的 require 块中。



**go get**

**在 Go 1.17 版本中，go get 已经不再被用来安装某个命令的可执行文件了**。如果你依旧使用 go get 安装，Go 命令会 提示错误

新版本中，我们需要使用 go install 来安装，并且**使用 go install 安装时还要用 @vx.y.z 明确要安装的命令的二进制文件的版本，或者是使用 @latest 来安装最新版本。**



**go:build 形式的构建约束指示**

在 Go 1.17 之前，我们可以通过在源码文件头部放置 // +build 构建约束指示符来实现构 建约束，但这种形式十分易错，并且它并不支持 && 和||这样的直观的逻辑操作符，而是 用逗号、空格替代，这里你可以看下原 // +build 形式构建约束指示符的用法及含义：

![image-20221121104356629](markdown%E5%9B%BE%E7%89%87/image-20221121104356629.png)

Go 1.17 回归“正规正 轨”，引入了//go:build 形式的构建约束指示符。一方面，这可以与源文件中的其他指 示符保持形式一致，比如 //go:nosplit、//go:norace、//go:noinline、//go:generate 等。 另一方面，新形式将支持 && 和||逻辑操作符，这样的形式就是自解释的，这样，我们程 序员就不需要再像上面那样列出一个表来解释每个指示符组合的含义了。新形式是这样 的：

![image-20221121104514896](markdown%E5%9B%BE%E7%89%87/image-20221121104514896.png)



## 改善Go编程质量的有效实践

### 使用 pkg/errors 而不是官方 error 库

在一个项目中使用错误机制，最核心的几个需求是什么？我 觉得主要是这两点：

- **附加信息**：我们希望错误出现的时候能附带一些描述性的错误信息，甚至这些信息是可 以嵌套的； 
- **附加堆栈**：我们希望错误不仅仅打印出错误信息，也能打印出这个错误的堆栈信息，让 我们可以知道出错的具体代码。



### 初始化 slice 的时候尽量补全 cap

方法一，直接使用[]int 的方式来初始化：

```go
arr := []int{}
arr = append(arr, 1, 2, 3, 4, 5)
```

方法二，使用 make 关键字来初始化:

```go
arr := make([]int, 0, 5)
arr = append(arr, 1, 2, 3, 4, 5)
```

这两种方法对应的功能和输出结果是没有任何差别的，但是实际运行的时候，方法 二会比方法一少运行了一个 growslice 的命令，能够提升我们程序的运行性能



### 初始化一个类的时候，如果类的构造参数较多，尽量使用 Option 写法

当我们遇到一定要初始化一个类的时候，大部分时候，我们都会使用类似下列的 New 方 法

```go
type Foo struct {
    name string
    id int
    age int
    db interface{}
}
func NewFoo(name string, id int, age int, db interface{}) *Foo {
	return &Foo{
        name: name,
        id: id,
        age: age,
        db: db,
    }
}

```

一旦 Foo 结构内部的字段发生了变化，增加或者减 少了，那么这个初始化函数 NewFoo 就怎么看怎么别扭了。

这里其实有一种更好的写法：**使用 Option 写法来进行改造(职责链模式)。**

Option 写法，顾名思义，就是将所有可选的参数作为一个可选方式，一般我们会设计一 个“函数类型”来代表这个 Option，然后配套将所有可选字段设计为一个这个函数类型的 具体实现。在具体的使用的时候，使用可变字段的方式来控制有多少个函数类型会被执 行。

```go
type Foo struct {
    name string
    id int
    age int
    db interface{}
}
// FooOption 代表可选参数
type FooOption func(foo *Foo)
// WithName 代表Name为可选参数
func WithName(name string) FooOption {
    return func(foo *Foo) {
   		 foo.name = name
    }
}
// WithAge 代表age为可选参数
func WithAge(age int) FooOption {
    return func(foo *Foo) {
    	foo.age = age
    }
}
// WithDB 代表db为可选参数
func WithDB(db interface{}) FooOption {
    return func(foo *Foo) {
   		 foo.db = db
    }
}
// NewFoo 代表初始化
func NewFoo(id int, options ...FooOption) *Foo {
    foo := &Foo{
        name: "default",
        id: id,
        age: 10,
        db: nil,
	}
    for _, option := range options {
    	option(foo)
    }
	return foo
}
```



### 巧用大括号控制变量作用域

在写 Go 的过程中，你一定有过为 := 和 = 烦恼的时刻。一个变量，到写的时候，我还要 记得前面是否已经定义过了，如果没有定义过，使用 := ，如果已经定义过，使用 =。

之前写过的一个命令行工具的例子。我们都知道写命令行工具，对传递的参数 的解析需要有一些逻辑：“如果参数中有某个字段，那么就解析并存储到变量中，如果没 有，就记录 error”，这里我就使用了大括号，将每个参数的解析和处理错误的逻辑都封装 起来。

```go
var name string
var folder string
var mod string
...
{
    prompt := &survey.Input{
        Message: "请输入目录名称：",
	}
    err := survey.AskOne(prompt, &name)
    if err != nil {
   	 return err
	}
...
}

{
    prompt := &survey.Input{
    Message: "请输入模块名称(go.mod中的module, 默认为文件夹名称)：",
    }
    err := survey.AskOne(prompt, &mod)
    if err != nil {
    return err
    }
...
}
```

整段代码的作用是解析出三个变量 name、mod、 version。最开始我们先定义这三个变量，然后使用三个大括号，分别将这三个变量的解析 逻辑封装在里面。这样，每个大括号里面的 err 变量的作用域就完全局限在括号中了。所 以，我们每次都可以直接使用 := 来创建一个新的 err 并处理它，不用再额外思考这个 err 变量是否前面已经创建过了。

**大括号在代码语义上还有一个好处，就是归类和展示。** 归类的意思就是，这个大括号里面的变量和逻辑是一个完整的部分，他们内部创建的变量 不会泄漏到外部。















## 作为Go Module的作者，你应该知道的几件事

之前的讲解更多是从 Go Module 的使用者角度出发的。在这篇中，我们再从 Go Module 的作者或维护者的视角，来聊聊在规划、发布和维护 Go Module 时需要考虑 和注意什么事情，包括 go 项目仓库布局、Go Module 的发布、升级 module 主版本号、 作废特定版本的 module，等等。

> **仓库布局：是单 module 还是多 module**

**如果没有单一仓库（monorepo）的强约束**，那么在默认情况下，你选择一个仓库管理一个 module 是不会错的，这是管理 Go Module 的最简单的方式，也是最常用的标准方式。这种方式下，module 维护者维护起来会很方便，module 的使用者在引用 module 下面的包时，也可以很容易地确定包的导入路径。举个简单的例子，我们在 github.com/bigwhite/srsm 这个仓库下管理着一个 GoModule（srsm 是 single repo single module 的缩写）。**通常情况下，module path 与仓库地址保持一致**，都是 github.com/bigwhite/srsm，这点会体现在 go.mod 中：

```go
// go.mod
module github.com/bigwhite/srsm

go 1.17
```

然后我们**对仓库打 tag，这个 tag 也会成为 Go Module 的版本号，这样，对仓库的版本管理其实就是对 Go Module 的版本管理。**

如果这个仓库下的布局是这样的：

```go
./srsm
├── go.mod
├── go.sum
├── pkg1/
│   └── pkg1.go
└── pkg2/
    └── pkg2.go
```

那么这个 module 的使用者可以很轻松地确定 pkg1 和 pkg2 两个包的导入路径，一个是 github.com/bigwhite/srsm/pkg1，另一个则是 github.com/bigwhite/srsm/pkg2。

如果 module 演进到了 v2.x.x 版本，那么以 pkg1 包为例，它的包的导入路径就变成了 github.com/bigwhite/srsm/v2/pkg1。



**如果组织层面要求采用单一仓库（monorepo）模式**，也就是所有 Go Module 都必须放在一个 repo 下，那我们只能使用单 repo 下管理多个 Go Module 的方法了。记得 Go Module 的设计者 Russ Cox 曾说过：**“在单 repo 多 module 的布局下，添加 module、删除 module，以及对 module 进行版本管理，都需要相当谨慎和深思熟虑，因此，管理一个单 module 的版本库，几乎总是比管理现有版本库中的多个 module 要容易和简单**”。

我们也用一个例子来感受一下这句话的深意。这里是**一个单 repo 多 module 的例子**，我们假设 repo 地址github.com/bigwhite/srmm。这个 repo 下的结构布局如下（srmm 是 single repo multiple modules 的缩写）：

```go
./srmm
├── module1
│   ├── go.mod
│   └── pkg1
│       └── pkg1.go
└── module2
    ├── go.mod
    └── pkg2
        └── pkg2.go
```

srmm 仓库下面有两个 Go Module，分为位于子目录 module1 和 module2 的下面，这两个目录也是各自 module 的根目录（module root）。这种情况下，module 的 path 也不能随意指定，必须包含子目录的名字。我们以 module1 为例分析一下，它的 path 是 github.com/bigwhite/srmm/module1，只有这样，Go 命令才能根据用户导入包的路径，找到对应的仓库地址和在仓库中的相对位置。同理，module1 下的包名同样是以 module path 为前缀的，比如：github.com/bigwhite/srmm/module1/pkg1。

在单仓库多 module 模式下，各个 module 的版本是独立维护的。因此，我们在通过打 tag 方式发布某个 module 版本时，tag 的名字必须包含子目录名。比如：如果我们要发布 module1 的 v1.0.0 版本，我们不能通过给仓库打 v1.0.0 这个 tag 号来发布 module1 的 v1.0.0 版本，正确的作法应该是打 module1/v1.0.0 这个 tag 号。你现在可能觉得这样理解起来也没有多复杂，但当各个 module 的主版本号升级时，你就会感受到这种方式带来的繁琐了，这个我们稍后再细说。



> **发布Go Module**

当我们的 module 完成开发与测试，module 便可以发布了。**发布的步骤也十分简单，就是为 repo 打上 tag 并推送到代码服务器上就好了**。如果采用单 repo 单 module 管理方式，那么我们给 repo 打的 tag 就是 module 的版本。如果采用的是单 repo 多 module 的管理方式，那么我们就需要注意在 tag 中加上各个 module 的子目录名，这样才能起到发布某个 module 版本的作用，否则 module 的用户通过 go get xxx@latest 也无法看到新发布的 module 版本。而且，这里还有一个需要你特别注意的地方，如果你在发布正式版之前先发布了 alpha 或 beta 版给大家公测使用，那么你一定要提醒你的 module 的使用者，让他们通过 go get 指定公测版本号来显式升级依赖，比如：

```go
$go get github.com/bigwhite/srsm@v1.1.0-beta.1
```

这样，go get 工具才会将使用者项目依赖的 github.com/bigwhite/srsm 的版本更新为 v1.1.0-beta.1。而我们通过go get github.com/bigwhite/srsm@latest，是不会获取到像上面 v1.1.0-beta.1 这样的发布前的公测版本的。多数情况下，Go Module 的维护者可以正确地发布 Go Module。

但人总是会犯错的，作为 Go Module 的作者或维护者，我们偶尔也会出现这样的低级错误：**将一个处于 broken 状态的 module 发布了出去**。那一旦出现这样的情况，我们该怎么做呢？我们继续向下看。



> **作废特定版本的 Go Module**

我们先来看看如果发布了错误的 module 版本会对 module 的使用者带去什么影响。我们直接来看一个例子。假设 bitbucket.org/bigwhite/m1 是我维护的一个 Go Module，它目前已经演进到 v1.0.1 版本了，并且有两个使用者 c1 和 c2，你可以看下这个示意图，能更直观地了解 m1 当前的状态：

![image-20221121202936977](markdown%E5%9B%BE%E7%89%87/image-20221121202936977.png)

某一天，我一不小心，就把一个处于 broken 状态的 module 版本，m1@v1.0.2 发布出去了！此时此刻，m1 的 v1.0.2 版本还只存在于它的源仓库站点上，也就是 bitbucket/bigwhite/m1 中，在任何一个 GoProxy 服务器上都还没有这个版本的缓存。这个时候，依赖 m1 的两个项目 c1 和 c2 依赖的仍然是 m1@v1.0.1 版本。也就是说，如果没有显式升级 m1 的版本，c1 和 c2 的构建就不会受到处于 broken 状态的 module v1.0.2 版本的影响，这也是 Go Module 最小版本选择的优点。而且，由于 m1@v1.0.2 还没有被 GoProxy 服务器缓存，在 GOPROXY 环境变量开启的情况下，go list 是查不到 m1 有可升级的版本的：

```go

// 以c2为例：
$go list -m -u all
github.com/bigwhite/c2
bitbucket.org/bigwhite/m1 v1.0.1
```

但如若我们绕开 GOPROXY，那么 go list 就可以查找到 m1 的最新版本为 v1.0.2（我们通过设置 GONOPROXY 来让 go list 查询 m1 的源仓库而不是代理服务器上的缓存）：

```go

$GONOPROXY="bitbucket.org/bigwhite/m1" go list -m -u all
github.com/bigwhite/c2
bitbucket.org/bigwhite/m1 v1.0.1 [v1.0.2]
```

之后，如果某个 m1 的消费者，比如 c2，通过 go get bitbucket.org/bigwhite/m1@v1.0.2 对 m1 的依赖版本进行了显式更新，那就会触发 GOPROXY 对 m1@v1.0.2 版本的缓存。这样一通操作后，module proxy 以及 m1 的消费者的当前的状态就会变成这样：



由于 Goproxy 服务已经缓存了 m1 的 v1.0.2 版本，这之后，m1 的其他消费者，比如 c1 就能够在 GOPROXY 开启的情况下查询到 m1 存在新版本 v1.0.2，即便它是 broken 的：

```go

// 以c1为例：
$go list -m -u all
github.com/bigwhite/c1
bitbucket.org/bigwhite/m1 v1.0.1 [v1.0.2]
```



但是，一旦 broken 的 m1 版本（v1.0.2）进入到 GoProxy 的缓存，那么它的“危害性”就会“大肆传播”开。这时 module m1 的新消费者都将受到影响！比如这里我们引入一个新的消费者 c3，c3 的首次构建就会因 m1 的损坏而报错：

![image-20221121203117998](markdown%E5%9B%BE%E7%89%87/image-20221121203117998.png)

到这里，糟糕的情况已经出现了！那我们怎么作废掉 m1@v1.0.2 版本来修复这个问题呢？如果在 GOPATH 时代，废掉一个之前发的包版本是分分钟的事情，因为那时包消费者依赖的都是 latest commit。包作者只要 fix 掉问题、提交并重新发布就可以了。但是在 Go Module 时代，作废掉一个已经发布了的 Go Module 版本还真不是一件能轻易做好的事情。这很大程度是源于大量 Go Module 代理服务器的存在，Go Module 代理服务器会将已发布的 broken 的 module 缓存起来。下面我们来看看可能的问题解决方法。



> **修复 broken 版本并重新发布**



要解决掉这个问题，Go Module 作者有一个很直接的解决方法，就是：**修复 broken 的 module 版本并重新发布**。它的操作步骤也很简单：m1 的作者只需要删除掉远程的 tag: v1.0.2，在本地 fix 掉问题，然后重新 tag v1.0.2 并 push 发布到 bitbucket 上的仓库中就可以了。

但这样做真的能生效么？理论上，如果 m1 的所有消费者，都通过 m1 所在代码托管服务器（bitbucket）来获取 m1 的特定版本，那么这种方法还真能解决掉这个问题。对于已经 get 到 broken v1.0.2 的消费者来说，他们只需清除掉本地的 module cache（go clean -modcache），然后再重新构建就可以了；对于 m1 的新消费者，他们直接得到的就是重新发布后的 v1.0.2 版本。

但现实的情况时，现在大家都是通过 Goproxy 服务来获取 module 的。

所以，一旦一个 module 版本被发布，当某个消费者通过他配置的 goproxy 获取这个版本时，这个版本就会在被缓存在对应的代理服务器上。后续 m1 的消费者通过这个 goproxy 服务器获取那个版本的 m1 时，请求不会再回到 m1 所在的源代码托管服务器。这样，即便 m1 的源服务器上的 v1.0.2 版本得到了重新发布，散布在各个 goproxy 服务器上的 broken v1.0.2 也依旧存在，并且被“传播”到各个 m1 消费者的开发环境中，而重新发布后的 v1.0.2 版本却得不到“传播”的机会，我们还是用一张图来直观展示下这种“窘境”：

![image-20221121203109846](markdown%E5%9B%BE%E7%89%87/image-20221121203109846.png)

因此，从消费者的角度看，m1 的 v1.0.2 版本依旧是那个 broken 的版本，这种解决措施无效！

那你可能会问，如果 m1 的作者删除了 bitbucket 上的 v1.0.2 这个发布版本，各大 goproxy 服务器上的 broken v1.0.2 版本是否也会被同步删除呢？遗憾地告诉你：不会。

Goproxy 服务器当初的一个设计目标，就是尽可能地缓存更多 module。所以，即便某个 module 的源码仓库都被删除了，这个 module 的各个版本依旧会缓存在 goproxy 服务器上，这个 module 的消费者依然可以正常获取这个 module，并顺利构建。因此，goproxy 服务器当前的实现都没有主动删掉某个 module 缓存的特性。当然了，这可能也不是绝对的，毕竟不同 goproxy 服务的实现有所不同。那这种问题该怎么解决呢？

这种情况下，Go 社区更为常见的解决方式就是发布 module 的新 patch 版本



> **发布 module 的新 patch 版本**



我们依然以上面的 m1 为例，现在我们废除掉 v1.0.2，在本地修正问题后，直接打 v1.0.3 标签，并发布 push 到远程代码服务器上。这样 m1 的消费者以及 module proxy 的整体状态就变成这个样子了：

![image-20221121203100698](markdown%E5%9B%BE%E7%89%87/image-20221121203100698.png)

在这样的状态下，我们分别看看 m1 的消费者的情况：

- 对于依赖 m1@v1.0.1 版本的 c1，在未手工更新依赖版本的情况下，它仍然可以保持成功的构建；
- 对于 m1 的新消费者，比如 c4，它首次构建时使用的就是 m1 的最新 patch 版 v1.0.3，跨过了作废的 v1.0.2，并成功完成构建；
- 对于之前曾依赖 v1.0.2 版本的消费者 c2 来说，这个时候他们需要手工介入才能解决问题，也就是需要在 c2 环境中手工升级依赖版本到 v1.0.3，这样 c2 也会得到成功构建。

那这样，我们错误版本的问题就得到了缓解。从 Go 1.16 版本开始，Go Module 作者还可以在 go.mod 中使用新增加的retract 指示符，标识出哪些版本是作废的且不推荐使用的。retract 的语法形式如下：

```go
// go.mod
retract v1.0.0           // 作废v1.0.0版本
retract [v1.1.0, v1.2.0] // 作废v1.1.0和v1.2.0两个版本
```

我们还用 m1 为例，我们将 m1 的 go.mod 更新为如下内容：

```go
//m1的go.mod
module bitbucket.org/bigwhite/m1

go 1.17

retract v1.0.2
```

然后将 m1 放入 v1.0.3 标签中并发布。现在 m1 的消费者 c2 要查看 m1 是否有最新版本时，可以查看到以下内容（c2 本地环境使用 go1.17 版本）：

```go

$GONOPROXY=bitbucket.org/bigwhite/m1 go list -m -u all
... ...
bitbucket.org/bigwhite/m1 v1.0.2 (retracted) [v1.0.3]
```

从 go list 的输出结果中，我们看到了 v1.0.2 版本上有了 retracted 的提示，提示这个版本已经被 m1 的作者作废了，不应该再使用，应升级为 v1.0.3。但 retracted 仅仅是一个提示作用，并不影响 go build 的结果，c2 环境（之前在 go.mod 中依赖 m1 的 v1.0.2）下的 go build 不会自动绕过 v1.0.2，除非显式更新到 v1.0.3。不过，上面的这个 retract 指示符适合标记要作废的独立的 minor 和 patch 版本，如果要提示用某个 module 的某个大版本整个作废，我们用 Go 1.17 版本引入的 Deprecated 注释行更适合。下面是使用 Deprecated 注释行的例子：

```go

// Deprecated: use bitbucket.org/bigwhite/m1/v2 instead.
module bitbucket.org/bigwhite/m1
```



> **升级 module 的 major 版本号**



随着 module 的演化，总有一天 module 会出现不兼容以前版本的 change，这就到了需要升级 module 的 major 版本号的时候了。在前面的讲解中，我们学习了 Go Module 的语义导入版本机制，也就是 Go Module 规定：**如果同一个包的新旧版本是兼容的，那么它们的包导入路径应该是相同的**。反过来说，如果新旧两个包不兼容，那么应该采用不同的导入路径。而且，我们知道，Go 团队采用了将“major 版本”作为导入路径的一部分的设计。这种设计支持在同一个项目中，导入同一个 repo 下的不同 major 版本的 module，比如：

```go

import (
    "bitbucket.org/bigwhite/m1/pkg1"   // 导入major版本号为v0或v1的module下的pkg1
    pkg1v2 "bitbucket.org/bigwhite/m1/v2/pkg1" // 导入major版本号为v2的module下的pkg1
)
```

我们可以认为：**在同一个 repo 下，不同 major 号的 module 就是完全不同的 module**，甚至同一 repo 下，不同 major 号的 module 可以相互导入。这样一来，对于 module 作者 / 维护者而言，升级 major 版本号，也就意味着高版本的代码要与低版本的代码彻底分开维护，通常 Go 社区会采用为新的 major 版本建立新的 major 分支的方式，来将不同 major 版本的代码分离开，这种方案被称为“major branch”的方案。major branch 方案对于多数 gopher 来说，是一个过渡比较自然的方案，它通过建立 vN 分支并基于 vN 分支打 vN.x.x 的 tag 的方式，做 major 版本的发布。

那么，采用这种方案的 Go Module 作者升级 major 版本号时要怎么操作呢？我们以将 bitbucket.org/bigwhite/m1 的 major 版本号升级到 v2 为例看看。首先，我们要建立 v2 代码分支并切换到 v2 分支上操作，然后修改 go.mod 文件中的 module path，增加 v2 后缀：

```go

//go.mod
module bitbucket.org/bigwhite/m1/v2

go 1.17
```

这里要特别注意一点，如果 module 内部包间有相互导入，那么在升级 major 号的时候，这些包的 import 路径上也要增加 v2，否则，就会存在在高 major 号的 module 代码中，引用低 major 号的 module 代码的情况，**这也是 module 作者最容易忽略的事情**。

这样一通操作后，我们就将 repo 下的 module 分为了两个 module 了，一个是原先的 v0/v1 module，在 master/main 分支上；新建的 v2 分支承载了 major 号为 2 的 module 的代码。major 号升级的这个操作过程还是很容易出错的，你操作时一定要谨慎。对于消费者而言，在它依赖的 module 进行 major 版本号升级后，他们只需要在这个依赖 module 的 import 路径的后面，增加 /vN 就可以了（这里是 /v2），当然代码中也要针对不兼容的部分进行修改，然后 go 工具就会自动下载相关 module。

早期 Go 团队还提供了利用子目录分割不同 major 版本的方案，我们也看看这种方式怎么样。我们还是以 bitbucket.org/bigwhite/m1 为例，如果这个 module 已经演化到 v3 版本了，那么这个 module 所在仓库的目录结构应该是这样的：

```go

# tree m1
m1
├── pkg1
│   └── pkg1.go
├── go.mod
├── v2
│   ├── pkg1 
│   │   └── pkg1.go
│   └── go.mod
└── v3
    ├── pkg1 
    │   └── pkg1.go
    └── go.mod
```

这里我们直接用 vN 作为子目录名字，在代码仓库中将不同版本 module 放置在不同的子目录中，这样，go 命令就会将仓库内的子目录名与 major 号匹配并找到对应版本的 module。从描述上看，似乎这种通过子目录方式来实现 major 版本号升级，会更“简单”一些。但我总感觉这种方式有些“怪”，而且，其他主流语言也很少有用这种方式进行 major 版本号升级的。另外一旦使用这种方式，我们似乎也很难利用 git 工具在不同 major 版本之间进行代码的 merge 了。目前 Go 文档中似乎也不再提这种方案了，**我个人也建议你尽量使用 major 分支方案。**

在实际操作中，也有一些 Go Module 的仓库，始终将 master 或 main 分支作为最高 major 版本的分支，然后建立低版本分支来维护低 major 版本的 module 代码，比如：etcd、go-redis等。这种方式本质上和前面建立 major 分支的方式是一样的，并且这种方式更符合一个 Go Module 演化的趋势和作者的意图，也就是低版本的 Go Module 随着时间的推移将渐渐不再维护，而最新最高版本的 Go Module 是 module 作者最想让使用者使用的版本。

**但在单 repo 多 module 管理方式下，升级 module 的 major 版本号有些复杂，我们需要分为两种情况来考虑。**

**第一种情况：**repo 下的所有 module 统一进行版本发布。

在这种情况下，我们只需要向上面所说的那样建立 vN 版本分支就可以了，在 vN 分支上对 repo 下所有 module 进行演进，统一打 tag 并发布。当然 tag 要采用带有 module 子目录名的那种方式，比如：module1/v2.0.0。etcd 项目对旗下的 Go Module 的统一版本发布，就是用的这种方式。如果翻看一下 etcd 的项目，你会发现 etcd 只会建立少量的像 release-3.4、release-3.5 这样的 major 分支，基于这些分支，etcd 会统一发布 moduleName/v3.4.x 和 moduleName/v3.5.x 版本。

**第二个情况：**repo 下的 module 各自独立进行版本发布。

在这种情况下，简单创建一个 major 号分支来维护 module 的方式，就会显得不够用了，我们很可能需要建立 major 分支矩阵。假设我们的一个 repo 下管理了多个 module，从 m1 到 mN，那么 major 号需要升级时，我们就需要将 major 版本号与 module 做一个组合，形成下面的分支矩阵：

![image-20221121203047834](markdown%E5%9B%BE%E7%89%87/image-20221121203047834.png)

## 如何拉取私有的Go Module

GO Module机制下可能会有以下问题：

- 在某 module 尚未发布到类似 GitHub 这样的网站前，如何 import 这个本地的 module？
- 如何拉取私有 module？

> **导入本地 module**

Go Module 从 Go 1.11 版本开始引入到 Go 中，现在它已经成为了 Go 语言的依赖管理与构建的标准，因此，我也一直建议你彻底抛弃 Gopath 构建模式，全面拥抱 Go Module 构建模式。

**不过，如果我们的项目依赖的是本地正在开发、尚未发布到公共站点上的 Go Module，那么我们应该如何做呢？**



假设你有一个项目，这个项目中的 module a 依赖 module b，而 module b 是你另外一个项目中的 module，它本来是要发布到github.com/user/b上的。但此时此刻，module b 还没有发布到公共托管站点上，它源码还在你的开发机器上。也就是说，go 命令无法在github.com/user/b上找到并拉取 module a 的依赖 module b，这时，如果你针对 module a 所在项目使用 go mod tidy 命令，就会收到类似下面这样的**报错信息**：

```go

$go mod tidy
go: finding module for package github.com/user/b
github.com/user/a imports
    github.com/user/b: cannot find module providing package github.com/user/b: module github.com/user/b: reading https://goproxy.io/github.com/user/b/@v/list: 404 Not Found
    server response:
    not found: github.com/user/b@latest: terminal prompts disabled
    Confirm the import path was entered correctly.
    If this is a private repository, see https://golang.org/doc/faq#git_https for additional information.
```



这个时候，我们就可以借助 go.mod 的 replace 指示符，来解决这个问题。解决的步骤是这样的：

首先，我们需要在 module a 的 go.mod 中的 require 块中，手工加上这一条（这也可以通过 go mod edit 命令实现）：

```go
require github.com/user/b v1.0.0
```

**注意**：这里的 v1.0.0 版本号是一个“假版本号”，目的是满足 go.mod 中 require 块的语法要求。然后，我们再在 module a 的 go.mod 中使用 replace，将上面对 module b v1.0.0 的依赖，替换为本地路径上的 module b:

```go

replace github.com/user/b v1.0.0 => module b的本地源码路径
```

这样修改之后，go 命令就会让 module a 依赖你本地正在开发、尚未发布到代码托管网站的 module b 的源码了。而且，如果 module b 已经提交到类 GitHub 的站点上，但 module b 的作者正在本地开发新版本，那么上面这种方法，也同样适合 module b 的作者在本地测试验证 module b 的最新版本源码。虽然“伪造”go.mod 文件内容，可以解决上述这两个场景中的问题，**但显然这种方法也是有“瑕疵”的。**

- 首先，这个方法中，require 指示符将github.com/user/b v1.0.0替换为一个本地路径下的 module b 的源码版本，但这个本地路径是因开发者环境而异的。前面课程中我们讲过，go.mod 文件通常是要上传到代码服务器上的，这就意味着，另外一个开发人员下载了这份代码后，极大可能是无法成功编译的，他要想完成 module a 的编译，就得将 replace 后面的本地路径改为适配自己环境下的路径。于是，每当开发人员 pull 代码后，第一件事就是要修改 module a 的 go.mod 中的 replace 块，每次上传代码前，可能也要将 replace 路径复原，这是一个很糟心的事情。但即便如此，目前 Go 版本（最新为 Go 1.17.x）也没有一个完美的应对方案。针对这个问题，Go 核心团队在 Go 社区的帮助下，在预计 2022 年 2 月发布的 Go 1.18 版本中加入了 Go 工作区（Go workspace，也译作 Go 工作空间）辅助构建机制。基于这个机制，我们可以将多个本地路径放入同一个 workspace 中，这样，在这个 workspace 下各个 module 的构建将优先使用 workspace 下的 module 的源码。工作区配置数据会放在一个名为 go.work 的文件中，这个文件是开发者环境相关的，因此并不需要提交到源码服务器上，这就解决了上面“伪造 go.mod”方案带来的那些问题。



> **拉取私有 module 的需求与参考方案**

Go 1.11 版本引入 Go Module 构建模式后，用 Go 命令拉取项目依赖的公共 Go Module，已不再是“痛点”，我们只需要在每个开发机上为环境变量 GOPROXY，配置一个高效好用的公共 GOPROXY 服务，就可以轻松拉取所有公共 Go Module 了：

![image-20221121203133976](markdown%E5%9B%BE%E7%89%87/image-20221121203133976.png)

但随着公司内 Go 使用者和 Go 项目的增多，“重造轮子”的问题就出现了。抽取公共代码放入一个独立的、可被复用的内部私有仓库成为了必然，这样我们就有了**拉取私有 Go Module 的需求**。

一些公司或组织的所有代码，都放在公共 vcs 托管服务商那里（比如 github.com），私有 Go Module 则直接放在对应的公共 vcs 服务的 private repository（私有仓库）中。如果你的公司也是这样，那么拉取托管在公共 vcs 私有仓库中的私有 Go Module，也很容易，见下图：

![image-20221121203142654](markdown%E5%9B%BE%E7%89%87/image-20221121203142654.png)

也就是说，只要我们在每个开发机上，配置公共 GOPROXY 服务拉取公共 Go Module，同时再把私有仓库配置到 GOPRIVATE 环境变量，就可以了。这样，所有私有 module 的拉取，都会直连代码托管服务器，不会走 GOPROXY 代理服务，也不会去 GOSUMDB 服务器做 Go 包的 hash 值校验。当然，这个方案有一个前提，那就是每个开发人员都需要具有访问公共 vcs 服务上的私有 Go Module 仓库的权限，凭证的形式不限，可以是 basic auth 的 user 和 password，也可以是 personal access token（类似 GitHub 那种），只要按照公共 vcs 的身份认证要求提供就可以了。

不过，更多的公司 / 组织，可能会将私有 Go Module 放在公司 / 组织内部的 vcs（代码版本控制）服务器上，就像下面图中所示：

![image-20221121203151214](markdown%E5%9B%BE%E7%89%87/image-20221121203151214.png)

那么这种情况，我们该如何让 Go 命令，自动拉取内部服务器上的私有 Go Module 呢？这里给出两个参考方案。

**第一个方案是通过直连组织公司内部的私有 Go Module 服务器拉取。**

![image-20221121203159279](markdown%E5%9B%BE%E7%89%87/image-20221121203159279.png)

在这个方案中，我们看到，公司内部会搭建一个内部 goproxy 服务（也就是上图中的 in-house goproxy）。这样做有两个目的，一是为那些无法直接访问外网的开发机器，以及 ci 机器提供拉取外部 Go Module 的途径，二来，由于 in-house goproxy 的 cache 的存在，这样做还可以加速公共 Go Module 的拉取效率。另外，对于私有 Go Module，开发机只需要将它配置到 GOPRIVATE 环境变量中就可以了，这样，Go 命令在拉取私有 Go Module 时，就不会再走 GOPROXY，而会采用直接访问 vcs（如上图中的 git.yourcompany.com）的方式拉取私有 Go Module。这个方案十分适合内部有完备 IT 基础设施的公司。这类型的公司内部的 vcs 服务器都可以通过域名访问（比如 git.yourcompany.com/user/repo），因此，公司内部员工可以像访问公共 vcs 服务那样，访问内部 vcs 服务器上的私有 Go Module。

**第二种方案，是将外部 Go Module 与私有 Go Module 都交给内部统一的 GOPROXY 服务去处理：**

![image-20221121203208515](markdown%E5%9B%BE%E7%89%87/image-20221121203208515.png)

在这种方案中，开发者只需要把 GOPROXY 配置为 in-house goproxy，就可以统一拉取外部 Go Module 与私有 Go Module。但由于 go 命令默认会对所有通过 goproxy 拉取的 Go Module，进行 sum 校验（默认到 sum.golang.org)，而我们的私有 Go Module 在公共 sum 验证 server 中又没有数据记录。因此，开发者需要将私有 Go Module 填到 GONOSUMDB 环境变量中，这样，go 命令就不会对其进行 sum 校验了。不过这种方案有一处要注意：in-house goproxy 需要拥有对所有 private module 所在 repo 的访问权限，才能保证每个私有 Go Module 都拉取成功。你可以对比一下上面这两个参考方案，看看你更倾向于哪一个，我推荐第二个方案。在第二个方案中，我们可以**将所有复杂性都交给 in-house goproxy 这个节点**，开发人员可以无差别地拉取公共 module 与私有 module，心智负担降到最低。



## 提交前使用gofmt格式化源码

> **Go语言在解决规模化问题上的最佳实践：gofmt**

Go语言需要将良好的体验拓展到一定规模团队上，即规模化。

gofmt将一种统一的代码风格内置到Go语言中，成为了共识，也是Go语言的一大亮点



> **使用gofmt**

gofmt最大的特点是**没有提供任何关于代码风格设置的命令行选项和参数。**不过提供了按格式查找、代码重构的命令行选项。

**gofmt工具**一直是放置在Go安装包中与Go编译器一起发布。

gofmt 是一个独立的 client 程序，而Go语言中还有一个`go fmt`命令，`go fmt`命令是 gofmt 的简单封装。`go fmt`在调用 gofmt 时添加了`-l -w`参数，相当于执行了`gofmt -l -w`。

**gofmt -s**

```go
v := string{...}
for _ := range v {}
for range v {}
```

Go更推崇后面的简化写法。因此通过gofmt-s可以将遗留代码中的非简化代码自动转化为简化写法。这也是一个默认选项。



> **使用goimports**

Go编译器在编译源码时会对源码文件导入的包进行检查。

遗憾的是，gofmt工具无法自动增加或删除文件头部的包导入列表。因此Go实现了goimports，该工具在gofmt功能的基础上增加了对包导入列表的维护功能。

```go
go install golang.org/x/tools/cmd/goimports
```

如果Go编译器发现GOPATH/bin路径存在，就将goimports可执行文件放到该路径下。



> **将gofmt/goimports与IDE集成**

**Goland**

- 手工格式化：Tools-GoTools-Gofmtfile/Gofmtproject/Goimports file
- 保存文件时自动执行：FIie--setting-tools-File Watchers,然后添加一个File Watcher:goimports或者go fmt.

**VsCode**

只需要在安装vscode-go插件时按照提示安装vscode-go所依赖的第三方工具或者保证gofmt在环境变量PATH的路径中即可（把GOROOT/bin加入到PATH环境变量。）



## 使用Go命名惯例进行命名

至少要遵循俩个原则：

> **简单且一致**

**包**

- 一般以小写形式的单个单词命名

- 在Go中，包名可以不唯一，但包的导入路径唯一

- 包名应尽量与包导入路径的最后一个路径分段保持一致。

- 给包命名，不仅要考虑包自身的名字，还要兼顾该包导出的标识符命名。因为这些包导出标识符的引用必须以包名为前缀，所以对包导出标识符命名时，在名字中不要包含包名。

  ```go
  strings.Reader √
  strigns.StringReader ×
  ```



**变量、类型、函数、方法**

- 驼峰命名
  - 最常见：第一个词的首字母小写，后面每个词的首字母大写。
  - 包导出标识符：全部词的首字母大写。
- 简单、短小
  - 能单字母命名就单字母。
  - 保持变量声明与使用之间的距离越近越好
  - 保持简单命名变量含以上的一致性
    - 比如常用的v、k、i、t



**常量**

- 单词组合：考虑表达含义的准确性
- 全大写的特定常量：PI



**接口**

- 优先单个单词命名：对于拥有唯一方法或通过多个拥有唯一方法的接口组合而成的接口：“方法名+er”

  ```go
  type Closer interface{
      Close() error
  }
  type WriteCloser interface {
      Reader
      Writer
      Closer
  }
  ```

  Go推荐尽量定义小接口



> **利用上下文环境，让最短的名字携带足够多信息**

java和GO变量命名对比

| 变量含义 | java命名 | Go命名 |
| -------- | -------- | ------ |
| 下标     | index    | i      |
| 值       | value    | v      |

在for循环的上下文中，index、value携带的信息并不比i、v多。



## 使用复合字面值作为初值构造器

对于零值不适用的场景，为变量赋予一定的初值。对于复合类型，应该首选Go提供的符合字面值作为处置构造器、

**结构体**

使用filed:value形式作为复合字面值。



**数组/切片**

使用下标index作为field：value中的field。但是其应用 场景较少，一般在为非连续元素构造处置的情况下，然编译器根据最大元素下标值来推导数组的大小。

当元素类型为复合类型时，可以省去元素复合字面量中的类型



**map复合字面值**

当key或者value的类型为复合类型时，可以省去key或value中的复合字面量中的类型。







